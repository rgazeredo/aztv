{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Criar migration para tabela 'players' com campos essenciais",
        "description": "Implementar migration do Laravel para criar a tabela 'players' com todos os campos necessários para gerenciamento de dispositivos Android no sistema multi-tenant.",
        "details": "Criar arquivo de migration usando `php artisan make:migration create_players_table` com os seguintes campos:\n\n- `id` (bigint, primary key, auto increment)\n- `tenant_id` (bigint, foreign key para tenants.id, indexed)\n- `name` (string, nome do dispositivo)\n- `alias` (string, apelido personalizado, nullable)\n- `location` (string, localização física, nullable)\n- `group` (string, grupo organizacional, nullable)\n- `status` (enum: 'active', 'inactive', 'offline', 'error', default 'inactive')\n- `ip_address` (string, IP do dispositivo, nullable)\n- `last_seen` (timestamp, última atividade, nullable)\n- `app_version` (string, versão do app Android, nullable)\n- `device_info` (json, informações do hardware, nullable)\n- `activation_token` (string, token único para ativação, unique, nullable)\n- `settings` (json, configurações específicas do player, nullable)\n- `created_at` e `updated_at` (timestamps)\n\nIncluir índices apropriados:\n- Index em `tenant_id` para performance de queries multi-tenant\n- Index em `activation_token` para lookup rápido\n- Index em `status` para filtros de estado\n- Index composto em (`tenant_id`, `status`) para queries filtradas\n\nDefinir foreign key constraint para `tenant_id` com cascade delete.\nAdicionar comentários na tabela explicando o propósito de cada campo.",
        "testStrategy": "1. Executar a migration com `php artisan migrate` e verificar se a tabela foi criada corretamente\n2. Verificar estrutura da tabela no banco usando `php artisan tinker` e `DB::select('DESCRIBE players')`\n3. Testar foreign key constraint criando um player vinculado a um tenant existente\n4. Verificar índices criados usando queries EXPLAIN ou ferramentas de inspeção do banco\n5. Testar rollback da migration com `php artisan migrate:rollback` para garantir que o método `down()` funciona\n6. Validar que campos JSON (`device_info`, `settings`) aceitam dados válidos\n7. Verificar constraints de unicidade no campo `activation_token`",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Criar migration para tabela 'media_files' com campos essenciais",
        "description": "Implementar migration do Laravel para criar a tabela 'media_files' com todos os campos necessários para gerenciamento de arquivos de mídia no sistema multi-tenant.",
        "details": "Criar arquivo de migration usando `php artisan make:migration create_media_files_table` com os seguintes campos:\n\n- `id` (bigint, primary key, auto increment)\n- `tenant_id` (bigint, foreign key para tenants.id, indexed)\n- `filename` (string, nome único do arquivo no sistema)\n- `original_name` (string, nome original do arquivo enviado)\n- `mime_type` (string, tipo MIME do arquivo)\n- `size` (bigint, tamanho do arquivo em bytes)\n- `path` (string, caminho completo do arquivo)\n- `thumbnail_path` (string, caminho da thumbnail, nullable)\n- `duration` (integer, duração em segundos para vídeos, nullable)\n- `display_time` (integer, tempo de exibição padrão em segundos, nullable)\n- `folder` (string, pasta organizacional, nullable)\n- `tags` (json, tags para categorização, nullable)\n- `status` (enum: 'uploading', 'processing', 'ready', 'error', default 'uploading')\n- `created_at` e `updated_at` (timestamps)\n\nConfigurar:\n- Index composto em (tenant_id, status) para otimizar consultas\n- Index em filename para busca rápida\n- Foreign key constraint com cascade delete para tenant_id\n- Validação de tamanho máximo para campos de texto",
        "testStrategy": "1. Executar a migration com `php artisan migrate` e verificar se a tabela foi criada corretamente\n2. Verificar estrutura da tabela no banco usando `php artisan tinker` e `DB::select('DESCRIBE media_files')`\n3. Testar foreign key constraint criando um media_file vinculado a um tenant existente\n4. Verificar se os indexes foram criados corretamente usando `SHOW INDEX FROM media_files`\n5. Testar inserção de dados JSON no campo tags\n6. Verificar se os campos enum aceitam apenas valores válidos\n7. Testar rollback da migration com `php artisan migrate:rollback`",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Criar migration para tabela 'playlists' com campos essenciais",
        "description": "Implementar migration do Laravel para criar a tabela 'playlists' com todos os campos necessários para gerenciamento de listas de reprodução no sistema multi-tenant.",
        "details": "Criar arquivo de migration usando `php artisan make:migration create_playlists_table` com os seguintes campos:\n\n- `id` (bigint, primary key, auto increment)\n- `tenant_id` (bigint, foreign key para tenants.id, indexed)\n- `name` (string, nome da playlist, obrigatório)\n- `description` (text, descrição da playlist, nullable)\n- `is_default` (boolean, indica se é playlist padrão do tenant, default false)\n- `loop_enabled` (boolean, habilita reprodução em loop, default true)\n- `settings` (json, configurações específicas da playlist como tempo entre mídias, transições, etc.)\n- `created_at` (timestamp)\n- `updated_at` (timestamp)\n\nConsiderações importantes:\n- Adicionar índice composto em (tenant_id, is_default) para otimizar consultas de playlist padrão\n- Adicionar constraint única para garantir apenas uma playlist padrão por tenant\n- Configurar foreign key constraint com cascade delete para tenant_id\n- O campo settings deve permitir armazenar configurações como: tempo_entre_midias, tipo_transicao, volume_padrao, etc.",
        "testStrategy": "1. Executar a migration com `php artisan migrate` e verificar se a tabela foi criada corretamente\n2. Verificar estrutura da tabela no banco usando `php artisan tinker` e `DB::select('DESCRIBE playlists')`\n3. Testar foreign key constraint criando uma playlist vinculada a um tenant existente\n4. Verificar constraint única de is_default tentando criar duas playlists padrão para o mesmo tenant\n5. Testar inserção de dados JSON no campo settings\n6. Verificar índices criados usando `SHOW INDEX FROM playlists`\n7. Testar rollback da migration com `php artisan migrate:rollback`",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Criar migration para tabela 'playlist_items' com campos essenciais",
        "description": "Implementar migration do Laravel para criar a tabela 'playlist_items' que estabelece o relacionamento many-to-many entre playlists e media_files, incluindo campos para ordem e configurações de tempo.",
        "details": "Criar arquivo de migration usando `php artisan make:migration create_playlist_items_table` com os seguintes campos:\n\n- `id` (bigint, primary key, auto increment)\n- `playlist_id` (bigint, foreign key para playlists.id, indexed, onDelete cascade)\n- `media_file_id` (bigint, foreign key para media_files.id, indexed, onDelete cascade)\n- `order` (integer, ordem de exibição do item na playlist, unsigned, default 0)\n- `display_time_override` (integer, tempo de exibição em segundos para sobrescrever duração padrão, nullable)\n- `created_at` (timestamp)\n- `updated_at` (timestamp)\n\nConfigurar constraints:\n- Índice único composto em (playlist_id, order) para evitar duplicação de ordem\n- Índice único composto em (playlist_id, media_file_id) para evitar mídia duplicada na mesma playlist\n- Foreign key constraints com cascade delete\n\nAdicionar método down() para reverter a migration corretamente.",
        "testStrategy": "1. Executar a migration com `php artisan migrate` e verificar se a tabela foi criada corretamente\n2. Verificar estrutura da tabela no banco usando `php artisan tinker` e `DB::select('DESCRIBE playlist_items')`\n3. Testar foreign key constraints criando playlist_items vinculados a playlist e media_file existentes\n4. Verificar se os índices únicos estão funcionando tentando inserir registros duplicados\n5. Testar cascade delete removendo uma playlist e verificando se os playlist_items são removidos automaticamente\n6. Testar rollback da migration com `php artisan migrate:rollback` e verificar se a tabela é removida corretamente",
        "status": "done",
        "dependencies": [
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Criar migration para tabela 'player_playlists' (pivot)",
        "description": "Implementar migration do Laravel para criar a tabela pivot 'player_playlists' que estabelece o relacionamento many-to-many entre players e playlists, incluindo campos para agendamento e configurações específicas.",
        "details": "Criar arquivo de migration usando `php artisan make:migration create_player_playlists_table` com os seguintes campos:\n\n- `id` (bigint, primary key, auto increment)\n- `player_id` (bigint, foreign key para players.id, indexed, onDelete cascade)\n- `playlist_id` (bigint, foreign key para playlists.id, indexed, onDelete cascade)\n- `priority` (integer, prioridade de execução da playlist no player, unsigned, default 1)\n- `start_date` (datetime, data/hora de início da programação, nullable)\n- `end_date` (datetime, data/hora de fim da programação, nullable)\n- `schedule_config` (json, configurações de agendamento como dias da semana, horários específicos, recorrência, nullable)\n- `created_at` (timestamp)\n- `updated_at` (timestamp)\n\nAdicionar índices compostos:\n- Índice único em (`player_id`, `playlist_id`) para evitar duplicatas\n- Índice em (`player_id`, `priority`) para otimizar ordenação\n- Índice em (`start_date`, `end_date`) para consultas de agendamento\n\nConfigurar foreign key constraints com onDelete cascade para manter integridade referencial.",
        "testStrategy": "1. Executar a migration com `php artisan migrate` e verificar se a tabela foi criada corretamente\n2. Verificar estrutura da tabela no banco usando `php artisan tinker` e `DB::select('DESCRIBE player_playlists')`\n3. Testar foreign key constraints criando player_playlists vinculados a player e playlist existentes\n4. Verificar se os índices foram criados corretamente usando `SHOW INDEX FROM player_playlists`\n5. Testar constraint de unicidade tentando inserir duplicate entries para mesmo player_id e playlist_id\n6. Validar que campos JSON (schedule_config) aceitam dados válidos e rejeitam JSON inválido\n7. Testar cascade delete removendo um player ou playlist e verificando se registros relacionados são removidos",
        "status": "done",
        "dependencies": [
          1,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Criar migration para tabela 'apk_versions' com campos essenciais",
        "description": "Implementar migration do Laravel para criar a tabela 'apk_versions' com todos os campos necessários para gerenciamento de versões de APK do player Android no sistema multi-tenant.",
        "details": "Criar arquivo de migration usando `php artisan make:migration create_apk_versions_table` com os seguintes campos:\n\n- `id` (bigint, primary key, auto increment)\n- `tenant_id` (bigint, foreign key para tenants.id, indexed, nullable - versões globais podem não ter tenant)\n- `version` (string, número da versão do APK, obrigatório, único)\n- `filename` (string, nome do arquivo APK, obrigatório)\n- `path` (string, caminho completo do arquivo APK no storage, obrigatório)\n- `download_count` (integer, contador de downloads, unsigned, default 0)\n- `is_active` (boolean, indica se esta versão está ativa, default false)\n- `changelog` (text, descrição das mudanças desta versão, nullable)\n- `file_size` (bigint, tamanho do arquivo em bytes, unsigned, nullable)\n- `min_android_version` (string, versão mínima do Android suportada, nullable)\n- `created_at` (timestamp)\n- `updated_at` (timestamp)\n\nAdicionar índices apropriados:\n- Índice único composto em (tenant_id, version)\n- Índice em is_active para consultas rápidas de versões ativas\n- Foreign key constraint para tenant_id com onDelete cascade\n\nConfigurar soft deletes se necessário para manter histórico de versões.",
        "testStrategy": "1. Executar a migration com `php artisan migrate` e verificar se a tabela foi criada corretamente\n2. Verificar estrutura da tabela no banco usando `php artisan tinker` e `DB::select('DESCRIBE apk_versions')`\n3. Testar foreign key constraint criando uma apk_version vinculada a um tenant existente\n4. Verificar se o índice único (tenant_id, version) está funcionando tentando inserir versões duplicadas\n5. Testar inserção de dados com diferentes cenários: versão global (tenant_id null) e versão específica de tenant\n6. Verificar se os campos obrigatórios estão sendo validados corretamente\n7. Testar queries de performance nos índices criados",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Criar migration para tabela 'content_modules' com campos essenciais",
        "description": "Implementar migration do Laravel para criar a tabela 'content_modules' com todos os campos necessários para gerenciamento de módulos de conteúdo automático (clima, cotações, frases) no sistema multi-tenant.",
        "details": "Criar arquivo de migration usando `php artisan make:migration create_content_modules_table` com os seguintes campos:\n\n- `id` (bigint, primary key, auto increment)\n- `tenant_id` (bigint, foreign key para tenants.id, indexed, onDelete cascade)\n- `type` (enum: 'weather', 'quotes', 'currency', tipo do módulo de conteúdo)\n- `is_enabled` (boolean, indica se o módulo está ativo, default false)\n- `settings` (json, configurações específicas do módulo como API keys, intervalos de atualização, formatação, etc.)\n- `created_at` (timestamp, data de criação)\n- `updated_at` (timestamp, data da última atualização)\n\nAdicionar índices apropriados:\n- Index único composto em (tenant_id, type) para evitar duplicação de módulos por tenant\n- Index em tenant_id para consultas eficientes\n- Index em is_enabled para filtros de módulos ativos\n\nConfigurar foreign key constraint com onDelete cascade para manter integridade referencial quando tenant for excluído.",
        "testStrategy": "1. Executar a migration com `php artisan migrate` e verificar se a tabela foi criada corretamente\n2. Verificar estrutura da tabela no banco usando `php artisan tinker` e `DB::select('DESCRIBE content_modules')`\n3. Testar foreign key constraint criando um content_module vinculado a um tenant existente\n4. Verificar se o índice único composto (tenant_id, type) funciona tentando criar módulos duplicados\n5. Testar inserção de dados JSON válidos no campo settings\n6. Verificar se enum type aceita apenas valores válidos ('weather', 'quotes', 'currency')\n7. Testar cascata de exclusão removendo um tenant e verificando se content_modules relacionados são excluídos\n8. Executar `php artisan migrate:rollback` para testar reversão da migration",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Criar migration para tabela 'player_logs' com campos essenciais",
        "description": "Implementar migration do Laravel para criar a tabela 'player_logs' com todos os campos necessários para registro de logs e eventos dos dispositivos players no sistema multi-tenant.",
        "details": "Criar arquivo de migration usando `php artisan make:migration create_player_logs_table` com os seguintes campos:\n\n- `id` (bigint, primary key, auto increment)\n- `player_id` (bigint, foreign key para players.id, indexed, onDelete cascade)\n- `type` (enum: 'info', 'warning', 'error', 'debug', 'system', tipo do log)\n- `message` (text, mensagem descritiva do evento ou erro)\n- `data` (json, dados adicionais em formato JSON como stack traces, configurações, etc.)\n- `created_at` (timestamp, data/hora de criação do log)\n- `updated_at` (timestamp, data/hora de atualização)\n\nConfigurar:\n- Foreign key constraint para player_id com cascade delete\n- Index composto em (player_id, type, created_at) para consultas eficientes\n- Index em created_at para ordenação temporal\n- Charset utf8mb4 para suporte completo a caracteres especiais\n\nAdicionar método down() para rollback da migration removendo a tabela.",
        "testStrategy": "1. Executar a migration com `php artisan migrate` e verificar se a tabela foi criada corretamente\n2. Verificar estrutura da tabela no banco usando `php artisan tinker` e `DB::select('DESCRIBE player_logs')`\n3. Testar foreign key constraint criando um player_log vinculado a um player existente\n4. Verificar se os indexes foram criados corretamente com `SHOW INDEX FROM player_logs`\n5. Testar inserção de dados JSON no campo data usando `PlayerLog::create(['player_id' => 1, 'type' => 'info', 'message' => 'Teste', 'data' => ['key' => 'value']])`\n6. Verificar comportamento do cascade delete removendo um player e confirmando que seus logs foram removidos\n7. Testar rollback com `php artisan migrate:rollback` para garantir que o método down() funciona corretamente",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Criar model Player com relacionamentos e métodos essenciais",
        "description": "Implementar o model Player do Laravel com todos os relacionamentos necessários (belongsTo Tenant, belongsToMany Playlist, hasMany PlayerLog) e métodos de controle de status online.",
        "details": "Criar arquivo `app/Models/Player.php` usando `php artisan make:model Player` com os seguintes componentes:\n\n**Relacionamentos:**\n- `belongsTo(Tenant::class)` - cada player pertence a um tenant\n- `belongsToMany(Playlist::class, 'player_playlists')` - relacionamento many-to-many com playlists através da tabela pivot\n- `hasMany(PlayerLog::class)` - logs do player\n\n**Métodos essenciais:**\n- `isOnline()`: verifica se o player está online baseado no campo `last_seen_at` (considerar online se visto nos últimos 5 minutos)\n- `getStatus()`: retorna status atual ('online', 'offline', 'inactive') baseado em `last_seen_at` e `is_active`\n- `updateLastSeen()`: atualiza o campo `last_seen_at` com timestamp atual\n\n**Configurações adicionais:**\n- Fillable fields apropriados\n- Cast para `last_seen_at` como datetime\n- Cast para `settings` como array\n- Scope `active()` para filtrar players ativos\n- TenantScope middleware aplicado automaticamente",
        "testStrategy": "1. Criar factory para Player usando `php artisan make:factory PlayerFactory`\n2. Testar relacionamentos em `php artisan tinker`: criar player, associar tenant, verificar relacionamentos\n3. Testar método `isOnline()` com diferentes valores de `last_seen_at`\n4. Testar método `getStatus()` com combinações de `is_active` e `last_seen_at`\n5. Testar método `updateLastSeen()` verificando se timestamp é atualizado corretamente\n6. Verificar se TenantScope está funcionando corretamente\n7. Testar relacionamento many-to-many com Playlist através da tabela pivot",
        "status": "done",
        "dependencies": [
          1,
          5,
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Criar model MediaFile com relacionamentos e métodos essenciais",
        "description": "Implementar o model MediaFile do Laravel com relacionamentos para Tenant e Playlist, incluindo métodos para upload, geração de thumbnails e validação de arquivos de mídia.",
        "details": "Criar arquivo `app/Models/MediaFile.php` usando `php artisan make:model MediaFile` com os seguintes componentes:\n\n**Relacionamentos:**\n- `belongsTo(Tenant::class)` - cada arquivo de mídia pertence a um tenant\n- `belongsToMany(Playlist::class, 'playlist_media_files')` - relacionamento many-to-many com playlists através da tabela pivot\n\n**Métodos essenciais:**\n- `upload($file, $tenant)`: processa upload do arquivo, valida tipo/tamanho, salva no storage com path organizado por tenant\n- `generateThumbnail()`: gera thumbnail para vídeos/imagens usando FFmpeg ou biblioteca de imagem\n- `validateFile()`: valida formato, tamanho máximo, codec (para vídeos) baseado nas configurações do tenant\n- `getUrl()`: retorna URL pública do arquivo\n- `getThumbnailUrl()`: retorna URL do thumbnail gerado\n- `getDuration()`: para arquivos de vídeo, retorna duração em segundos\n- `getFileSize()`: retorna tamanho formatado do arquivo\n- `isVideo()`, `isImage()`, `isAudio()`: métodos helper para verificar tipo de mídia\n\n**Attributes/Casts:**\n- `metadata` cast para JSON (dimensões, codec, bitrate, etc.)\n- `duration` cast para integer\n- `file_size` cast para integer\n\n**Scopes:**\n- `whereType($type)`: filtrar por tipo de mídia\n- `whereTenant($tenantId)`: filtrar por tenant (usar TenantScope)\n\n**Configurações:**\n- Usar trait `HasFactory`\n- Configurar `$fillable` com campos seguros\n- Implementar validações no model usando rules",
        "testStrategy": "1. Criar factory para MediaFile usando `php artisan make:factory MediaFileFactory`\n2. Testar relacionamentos em `php artisan tinker`: criar media file, associar tenant e playlist, verificar relacionamentos\n3. Testar método `upload()` com diferentes tipos de arquivo (imagem, vídeo, áudio)\n4. Testar `validateFile()` com arquivos válidos e inválidos (tamanho, formato)\n5. Testar `generateThumbnail()` com arquivos de vídeo e imagem\n6. Testar métodos helper `isVideo()`, `isImage()`, `isAudio()` com diferentes tipos\n7. Testar scopes `whereType()` e `whereTenant()` retornando resultados corretos\n8. Verificar se o TenantScope está aplicado automaticamente\n9. Testar `getUrl()` e `getThumbnailUrl()` retornando URLs válidas\n10. Criar teste unitário para verificar casts JSON do campo `metadata`",
        "status": "done",
        "dependencies": [
          1,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Criar model Playlist com relacionamentos e métodos de reordenação",
        "description": "Implementar o model Playlist do Laravel com relacionamentos para Tenant, PlaylistItem e Player, incluindo métodos para reordenar items e gerenciar reprodução.",
        "details": "Criar arquivo `app/Models/Playlist.php` usando `php artisan make:model Playlist` com os seguintes componentes:\n\n**Relacionamentos:**\n- `belongsTo(Tenant::class)` - cada playlist pertence a um tenant\n- `hasMany(PlaylistItem::class)` - items da playlist ordenados por posição\n- `belongsToMany(Player::class, 'player_playlists')` - relacionamento many-to-many com players através da tabela pivot\n\n**Métodos essenciais:**\n- `reorderItems($itemIds)`: reordena items da playlist baseado no array de IDs fornecido, atualizando o campo `position` de cada PlaylistItem\n- `addItem($mediaFileId, $position = null)`: adiciona um item à playlist na posição especificada ou no final\n- `removeItem($itemId)`: remove item da playlist e reorganiza posições dos items restantes\n- `moveItem($itemId, $newPosition)`: move um item para nova posição\n- `getOrderedItems()`: retorna items da playlist ordenados por posição\n- `getDuration()`: calcula duração total da playlist baseada na duração dos media files\n- `isActive()`: verifica se a playlist está ativa para reprodução\n\n**Campos calculados:**\n- `items_count`: número de items na playlist\n- `total_duration`: duração total em segundos\n\n**Scopes:**\n- `scopeActive($query)`: filtra playlists ativas\n- `scopeWithItems($query)`: eager load dos items ordenados",
        "testStrategy": "1. Criar factory para Playlist usando `php artisan make:factory PlaylistFactory`\n2. Testar relacionamentos em `php artisan tinker`: criar playlist, associar tenant, players e items, verificar relacionamentos\n3. Testar método `reorderItems()` com array de IDs em diferentes ordens\n4. Testar métodos `addItem()` e `removeItem()` verificando atualização das posições\n5. Testar método `moveItem()` movendo items para diferentes posições\n6. Verificar cálculo de duração total com `getDuration()`\n7. Testar scopes `active()` e `withItems()`\n8. Criar teste unitário verificando integridade das posições após operações de reordenação",
        "status": "done",
        "dependencies": [
          1,
          9,
          10
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Criar model PlaylistItem com relacionamentos e métodos de ordenação",
        "description": "Implementar o model PlaylistItem do Laravel com relacionamentos belongsTo para Playlist e MediaFile, incluindo scope para ordenação sequencial dos items na playlist.",
        "details": "Criar arquivo `app/Models/PlaylistItem.php` usando `php artisan make:model PlaylistItem` com os seguintes componentes:\n\n**Relacionamentos:**\n- `belongsTo(Playlist::class)` - cada item pertence a uma playlist\n- `belongsTo(MediaFile::class)` - cada item referencia um arquivo de mídia\n\n**Scopes essenciais:**\n- `scopeOrdered($query)`: ordena items por posição (campo 'position')\n- `scopeForPlaylist($query, $playlistId)`: filtra items de uma playlist específica\n\n**Métodos essenciais:**\n- `updatePosition($newPosition)`: atualiza posição do item e reorganiza outros items\n- `moveToPosition($position)`: move item para nova posição na sequência\n- `getNextItem()`: retorna próximo item na playlist (baseado na posição)\n- `getPreviousItem()`: retorna item anterior na playlist\n\n**Configurações do model:**\n- Adicionar fillable: ['playlist_id', 'media_file_id', 'position', 'duration_override']\n- Configurar cast para 'position' como integer\n- Adicionar protected $with = ['mediaFile'] para eager loading",
        "testStrategy": "1. Criar factory para PlaylistItem usando `php artisan make:factory PlaylistItemFactory`\n2. Testar relacionamentos em `php artisan tinker`: criar playlist item, associar playlist e media file, verificar relacionamentos\n3. Testar scope `ordered()` criando múltiplos items com diferentes posições e verificando ordenação\n4. Testar método `updatePosition()` movendo item para diferentes posições e verificando reorganização\n5. Testar métodos `getNextItem()` e `getPreviousItem()` com sequência de items\n6. Criar teste unitário verificando funcionamento correto dos scopes e métodos de ordenação\n7. Testar integridade referencial com playlist e media file inexistentes",
        "status": "done",
        "dependencies": [
          10,
          11
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Criar model ApkVersion com métodos para download tracking e validação de versão",
        "description": "Implementar o model ApkVersion do Laravel com relacionamentos para Tenant e Player, incluindo métodos para controle de versões de APK, tracking de downloads e validação de compatibilidade.",
        "details": "Criar arquivo `app/Models/ApkVersion.php` usando `php artisan make:model ApkVersion` com os seguintes componentes:\n\n**Relacionamentos:**\n- `belongsTo(Tenant::class)` - cada versão de APK pertence a um tenant\n- `hasMany(Player::class)` - players que usam esta versão\n- `hasMany(ApkDownload::class)` - tracking de downloads desta versão\n\n**Métodos essenciais:**\n- `isLatest()`: verifica se esta é a versão mais recente para o tenant\n- `isCompatibleWith($playerVersion)`: valida compatibilidade com versão do player\n- `trackDownload($playerId, $ipAddress = null)`: registra download da versão\n- `getDownloadUrl($playerId = null)`: gera URL segura para download com token temporário\n- `incrementDownloadCount()`: incrementa contador de downloads\n- `getVersionComparison($otherVersion)`: compara versões usando semantic versioning\n\n**Scopes:**\n- `scopeLatest($query)`: retorna apenas versões mais recentes\n- `scopeForTenant($query, $tenantId)`: filtra versões por tenant\n- `scopeActive($query)`: filtra apenas versões ativas/disponíveis\n\n**Atributos calculados:**\n- `download_count` (accessor): conta total de downloads\n- `is_latest` (accessor): booleano indicando se é a versão mais recente\n- `file_size_formatted` (accessor): tamanho do arquivo formatado (MB/GB)",
        "testStrategy": "1. Criar factory para ApkVersion usando `php artisan make:factory ApkVersionFactory`\n2. Testar relacionamentos em `php artisan tinker`: criar versão APK, associar tenant e players, verificar relacionamentos\n3. Testar método `isLatest()` criando múltiplas versões e verificando qual é identificada como mais recente\n4. Testar método `isCompatibleWith()` com diferentes combinações de versões\n5. Testar método `trackDownload()` e verificar se registros são criados corretamente\n6. Testar método `getDownloadUrl()` e verificar se URLs são geradas com tokens seguros\n7. Testar scopes `latest()`, `forTenant()` e `active()` com dados variados\n8. Testar comparação de versões com método `getVersionComparison()` usando semantic versioning\n9. Verificar se atributos calculados retornam valores corretos\n10. Testar increment de download count com concorrência simulada",
        "status": "done",
        "dependencies": [
          1,
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Criar model ContentModule com relacionamentos e métodos de configuração",
        "description": "Implementar o model ContentModule do Laravel com relacionamento belongsTo para Tenant e métodos para configuração e gerenciamento de módulos de conteúdo automático como clima, câmbio e frases motivacionais.",
        "details": "Criar arquivo `app/Models/ContentModule.php` usando `php artisan make:model ContentModule` com os seguintes componentes:\n\n**Relacionamentos:**\n- `belongsTo(Tenant::class)` - cada módulo de conteúdo pertence a um tenant\n- `belongsToMany(Playlist::class, 'playlist_content_modules')` - relacionamento many-to-many com playlists através da tabela pivot\n\n**Atributos essenciais:**\n- `module_type` (enum): 'weather', 'currency', 'quotes', 'custom'\n- `config` (JSON): configurações específicas do módulo (API keys, localização, intervalos de atualização)\n- `is_active` (boolean): status ativo/inativo do módulo\n- `update_interval` (integer): intervalo em minutos para atualização automática\n- `display_duration` (integer): tempo de exibição em segundos\n\n**Métodos essenciais:**\n- `updateConfig($config)`: atualiza configurações do módulo validando campos obrigatórios\n- `fetchContent()`: busca conteúdo atualizado baseado no tipo de módulo\n- `isConfigValid()`: valida se as configurações estão completas (API keys, etc.)\n- `getDisplayData()`: retorna dados formatados para exibição no player\n- `scheduleUpdate()`: agenda próxima atualização baseada no intervalo configurado\n\n**Scopes:**\n- `scopeActive($query)`: filtra apenas módulos ativos\n- `scopeByType($query, $type)`: filtra módulos por tipo específico\n- `scopeForTenant($query, $tenantId)`: filtra módulos de um tenant específico",
        "testStrategy": "1. Criar factory para ContentModule usando `php artisan make:factory ContentModuleFactory`\n2. Testar relacionamentos em `php artisan tinker`: criar módulo de conteúdo, associar tenant e playlists, verificar relacionamentos\n3. Testar método `updateConfig()` com diferentes configurações para cada tipo de módulo\n4. Testar método `isConfigValid()` com configurações válidas e inválidas\n5. Testar método `fetchContent()` mockando APIs externas para clima, câmbio e quotes\n6. Testar scopes `active()`, `byType()` e `forTenant()` criando múltiplos módulos com diferentes status e tipos\n7. Verificar casting automático do campo `config` para array/object\n8. Testar método `getDisplayData()` garantindo formato correto para exibição nos players",
        "status": "done",
        "dependencies": [
          1,
          11
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implementar AdminController com dashboard global e estatísticas",
        "description": "Criar o controller AdminController com métodos para exibir dashboard global com estatísticas de tenants, players totais, uso de storage e downloads de APKs para usuários admin.",
        "details": "Criar arquivo `app/Http/Controllers/AdminController.php` usando `php artisan make:controller AdminController` com os seguintes métodos:\n\n**Método dashboard():**\n- Retornar view `admin.dashboard` com dados agregados\n- Estatísticas de tenants: total de tenants ativos, novos registros no mês, tenants com subscription ativa\n- Estatísticas de players: total de players registrados, players online (últimas 24h), distribuição por tenant\n- Uso de storage: espaço total usado, espaço por tenant, arquivos de mídia por tipo\n- Downloads de APK: total de downloads, downloads por versão, downloads no período\n\n**Queries necessárias:**\n- `Tenant::count()` e `Tenant::whereMonth('created_at', now()->month)->count()`\n- `Player::count()` e `Player::where('last_seen_at', '>=', now()->subDay())->count()`\n- `MediaFile::sum('file_size')` e agregações por tenant\n- `ApkDownload::count()` e agregações por versão e período\n\n**Middleware aplicar:**\n- `auth` e middleware customizado para verificar role 'admin'\n- Verificação de permissão admin antes de exibir dados sensíveis\n\n**Estrutura da view:**\n- Cards com métricas principais\n- Gráficos simples usando Chart.js ou similar\n- Tabelas com top tenants por uso",
        "testStrategy": "1. Criar teste de feature `php artisan make:test AdminControllerTest` para verificar acesso apenas por usuários admin\n2. Testar método `dashboard()` retorna view correta com dados esperados\n3. Criar dados de teste: tenants, players, media files e downloads APK\n4. Verificar se estatísticas são calculadas corretamente comparando com queries manuais\n5. Testar middleware de autorização: usuário client não deve acessar rotas admin\n6. Testar performance das queries com dataset maior usando `debugbar` ou `telescope`\n7. Verificar se dados são formatados corretamente na view (números, datas, tamanhos de arquivo)",
        "status": "done",
        "dependencies": [
          1,
          9,
          10,
          13
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Criar controller TenantManagementController com CRUD completo para gerenciar clientes",
        "description": "Implementar o controller TenantManagementController com operações completas de CRUD para administradores gerenciarem tenants: criar, editar, excluir, suspender e ativar clientes no painel administrativo.",
        "details": "Criar arquivo `app/Http/Controllers/TenantManagementController.php` usando `php artisan make:controller TenantManagementController --resource` com os seguintes métodos:\n\n**Método index():**\n- Listar todos os tenants com paginação\n- Incluir filtros por status (ativo, suspenso), data de criação e nome\n- Retornar view `admin.tenants.index` com lista paginada\n- Incluir informações de subscription status e último acesso\n\n**Método create():**\n- Retornar view `admin.tenants.create` com formulário de criação\n- Incluir campos: name, slug, domain, email do proprietário\n- Validar unicidade de slug e domain\n\n**Método store(Request $request):**\n- Validar dados de entrada usando FormRequest\n- Criar novo tenant com User proprietário associado\n- Enviar email de boas-vindas com credenciais de acesso\n- Redirect para index com mensagem de sucesso\n\n**Método edit(Tenant $tenant):**\n- Retornar view `admin.tenants.edit` com dados do tenant\n- Incluir informações de subscription e usuários associados\n\n**Método update(Request $request, Tenant $tenant):**\n- Validar e atualizar dados do tenant\n- Manter histórico de alterações importantes\n- Redirect com mensagem de sucesso\n\n**Método destroy(Tenant $tenant):**\n- Soft delete do tenant (manter dados históricos)\n- Cancelar subscription ativa se existir\n- Notificar usuários sobre cancelamento\n\n**Métodos adicionais:**\n- `suspend(Tenant $tenant)`: suspender tenant temporariamente\n- `activate(Tenant $tenant)`: reativar tenant suspenso\n- `bulkActions(Request $request)`: ações em lote para múltiplos tenants\n\n**Middleware e autorização:**\n- Aplicar middleware 'auth' e verificação de role 'admin'\n- Usar policies para autorização granular\n- Logs de auditoria para todas as ações administrativas",
        "testStrategy": "1. Criar teste de feature `php artisan make:test TenantManagementControllerTest` para verificar acesso restrito a usuários admin\n2. Testar método `index()`: verificar paginação, filtros e dados retornados na view\n3. Testar `create()` e `store()`: criar tenant com dados válidos e inválidos, verificar validações\n4. Testar `edit()` e `update()`: atualizar tenant existente, verificar persistência de dados\n5. Testar `destroy()`: verificar soft delete e cancelamento de subscription\n6. Testar métodos `suspend()` e `activate()`: verificar mudanças de status e notificações\n7. Testar `bulkActions()`: selecionar múltiplos tenants e aplicar ações em lote\n8. Verificar middleware de autorização: tentar acesso com usuário não-admin\n9. Testar logs de auditoria: verificar se todas as ações são registradas corretamente\n10. Criar dados de teste com factory e verificar integridade referencial com subscriptions",
        "status": "done",
        "dependencies": [
          1,
          15
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Criar controller ApkManagementController para upload de APKs, geração de links curtos, QR codes e tracking de downloads",
        "description": "Implementar o controller ApkManagementController no painel administrativo para gerenciar upload de arquivos APK, gerar links curtos e QR codes para download, e realizar tracking completo de downloads por tenant e player.",
        "details": "Criar arquivo `app/Http/Controllers/ApkManagementController.php` usando `php artisan make:controller ApkManagementController --resource` com os seguintes métodos:\n\n**Método index():**\n- Listar todas as versões de APK com paginação\n- Incluir filtros por tenant, versão e data de upload\n- Mostrar estatísticas de downloads por versão\n- Retornar view `admin.apks.index` com lista paginada\n\n**Método create():**\n- Retornar view `admin.apks.create` com formulário de upload\n- Incluir seleção de tenant e configurações de versão\n- Validação de arquivo APK no frontend\n\n**Método store():**\n- Validar arquivo APK (tamanho máximo, formato, assinatura)\n- Fazer upload para storage configurado (local/S3)\n- Criar registro ApkVersion com metadata do arquivo\n- Gerar link curto usando biblioteca como `spatie/laravel-url-shortener`\n- Gerar QR code usando `simplesoftwareio/simple-qrcode`\n- Retornar resposta JSON com URL do APK e QR code\n\n**Método show($id):**\n- Exibir detalhes da versão APK específica\n- Mostrar estatísticas de download detalhadas\n- Incluir lista de players que usam esta versão\n- Exibir QR code e link curto para download\n\n**Método edit($id) e update($id):**\n- Permitir edição de metadata (versão, descrição)\n- Não permitir alteração do arquivo APK em si\n- Regenerar QR code se necessário\n\n**Método destroy($id):**\n- Soft delete da versão APK\n- Manter arquivo físico por 30 dias\n- Notificar tenants que usam esta versão\n\n**Métodos adicionais:**\n- `download($shortCode)`: servir arquivo APK via link curto e registrar download\n- `generateQrCode($id)`: regenerar QR code para versão específica\n- `downloadStats($id)`: retornar estatísticas de download em JSON\n- `bulkDelete()`: exclusão em lote de versões antigas\n\n**Middleware e Autorização:**\n- Aplicar middleware `auth` e verificação de role admin\n- Validar permissões por tenant quando aplicável\n- Rate limiting para downloads públicos\n\n**Integração com models:**\n- Usar ApkVersion::create() para persistir dados\n- Criar registros ApkDownload para tracking\n- Atualizar relacionamentos com Player quando aplicável",
        "testStrategy": "1. Criar teste de feature `php artisan make:test ApkManagementControllerTest` para verificar acesso restrito a usuários admin\n2. Testar método `index()`: verificar paginação, filtros e dados retornados na view\n3. Testar `store()`: upload de APK válido e inválido, verificar geração de link curto e QR code\n4. Testar `download()`: verificar download via link curto, registro de tracking e rate limiting\n5. Criar mock de storage para testar upload sem arquivos reais\n6. Testar `generateQrCode()`: verificar geração de QR code válido que aponta para link correto\n7. Testar `downloadStats()`: criar downloads de teste e verificar estatísticas retornadas\n8. Testar autorização: verificar que apenas admins podem acessar rotas de management\n9. Testar validação de arquivos: enviar arquivos não-APK e verificar rejeição\n10. Testar integração com ApkVersion model: verificar criação correta de registros no banco",
        "status": "done",
        "dependencies": [
          1,
          13,
          15
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Criar páginas React para dashboard administrativo com estatísticas, tabela de tenants e gráficos",
        "description": "Implementar as páginas React do painel administrativo incluindo dashboard com cards de estatísticas, tabela de gerenciamento de tenants e gráficos de uso da plataforma.",
        "details": "Criar as seguintes páginas React no diretório `resources/js/pages/admin/`:\n\n**Página AdminDashboard.tsx:**\n- Criar componente principal que consome dados do AdminController\n- Implementar cards de estatísticas: total de tenants, players online, uso de storage, downloads APK\n- Integrar gráficos usando recharts ou similar para visualização de dados temporais\n- Incluir filtros por período (7 dias, 30 dias, 3 meses)\n- Layout responsivo com grid de cards e seção de gráficos\n\n**Página TenantManagement.tsx:**\n- Tabela com listagem paginada de tenants usando DataTable do shadcn/ui\n- Colunas: nome, email, status subscription, data criação, último acesso, ações\n- Filtros por status (ativo, suspenso, cancelado) e busca por nome/email\n- Botões de ação: visualizar, editar, suspender/ativar, excluir\n- Modal de confirmação para ações destrutivas\n\n**Componentes de apoio:**\n- `StatCard.tsx`: componente reutilizável para cards de estatísticas\n- `UsageChart.tsx`: componente para gráficos de uso com diferentes tipos\n- `TenantActions.tsx`: dropdown com ações disponíveis para cada tenant\n\n**Integração com API:**\n- Configurar rotas no Laravel Wayfinder para type-safe routing\n- Implementar hooks customizados para fetch de dados administrativos\n- Tratamento de loading states e error handling\n- Implementar refresh automático dos dados a cada 30 segundos no dashboard",
        "testStrategy": "1. Criar testes de componente usando React Testing Library para verificar renderização correta dos cards de estatísticas e tabela de tenants\n2. Testar integração com API mockando respostas do AdminController e TenantManagementController\n3. Verificar responsividade das páginas em diferentes tamanhos de tela (mobile, tablet, desktop)\n4. Testar funcionalidades de filtro e busca na tabela de tenants\n5. Verificar se gráficos são renderizados corretamente com dados reais e dados vazios\n6. Testar navegação entre páginas e verificar se rotas type-safe funcionam corretamente\n7. Validar que apenas usuários admin conseguem acessar as páginas (teste de autorização)\n8. Testar states de loading e error em cenários de falha de API",
        "status": "done",
        "dependencies": [
          15,
          16
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Criar páginas React para gerenciamento de tenants com formulários de criação/edição e tabela com ações",
        "description": "Implementar páginas React completas para o painel administrativo permitindo criar, editar e gerenciar tenants através de formulários validados e tabela interativa com ações de suspender, ativar e deletar.",
        "details": "Criar as seguintes páginas React no diretório `resources/js/pages/admin/tenants/`:\n\n**Página TenantIndex.tsx:**\n- Implementar tabela responsiva com colunas: nome, slug, domain, status, subscription, data de criação\n- Adicionar filtros por status (ativo, suspenso), data e nome usando componentes shadcn/ui\n- Implementar paginação e busca em tempo real\n- Criar botões de ação: Editar, Suspender/Ativar, Deletar com confirmação\n- Integrar com API do TenantManagementController usando fetch ou axios\n- Adicionar loading states e tratamento de erros\n\n**Página TenantCreate.tsx:**\n- Criar formulário com campos: name, slug, domain, plan_id usando React Hook Form\n- Implementar validação client-side: slug único, domain válido, campos obrigatórios\n- Integrar com endpoint POST /admin/tenants do TenantManagementController\n- Adicionar feedback visual (toast) para sucesso/erro\n- Redirecionar para index após criação bem-sucedida\n\n**Página TenantEdit.tsx:**\n- Formulário similar ao create, mas populado com dados existentes\n- Permitir edição de informações básicas e troca de plano\n- Implementar seção de ações administrativas: suspender/ativar conta\n- Integrar com endpoints PUT/PATCH do TenantManagementController\n- Incluir histórico de alterações e logs de atividade\n\n**Componentes auxiliares:**\n- TenantForm.tsx: formulário reutilizável para create/edit\n- TenantStatusBadge.tsx: badge visual para status do tenant\n- TenantActionButtons.tsx: botões de ação com confirmação\n- Utilizar componentes shadcn/ui: Table, Form, Button, Dialog, AlertDialog\n- Implementar theme responsivo e suporte a dark mode",
        "testStrategy": "1. Criar testes de componente usando React Testing Library para TenantIndex, TenantCreate e TenantEdit verificando renderização correta dos elementos\n2. Testar interações: busca, filtros, paginação, ações de suspender/ativar/deletar com confirmação\n3. Testar formulários: validação client-side, submissão com dados válidos e inválidos, estados de loading\n4. Mockar respostas da API do TenantManagementController para testar integração\n5. Verificar responsividade das páginas em diferentes tamanhos de tela usando viewport testing\n6. Testar navegação entre páginas e redirecionamentos após ações\n7. Verificar acessibilidade dos formulários e tabelas usando axe-core\n8. Testar estados de erro e loading, incluindo falhas de rede\n9. Verificar se toast notifications aparecem corretamente para feedback do usuário\n10. Testar performance da tabela com grandes volumes de dados mockados",
        "status": "done",
        "dependencies": [
          16,
          18
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Criar páginas React para gerenciamento de APKs com upload, lista de versões, geração de QR codes e estatísticas de download",
        "description": "Implementar páginas React completas no painel administrativo para upload de APKs, listagem de versões, visualização de QR codes e estatísticas detalhadas de downloads por tenant e player.",
        "details": "Criar as seguintes páginas React no diretório `resources/js/pages/admin/apks/`:\n\n**Página ApkIndex.tsx:**\n- Implementar tabela responsiva com colunas: versão, tenant, data de upload, tamanho do arquivo, downloads totais, status\n- Adicionar filtros por tenant, versão, data de upload e status usando componentes shadcn/ui\n- Implementar paginação e busca em tempo real\n- Criar botões de ação: Ver QR Code, Baixar APK, Editar, Deletar com confirmação\n- Integrar com API do ApkManagementController usando fetch\n- Adicionar modal para visualização de QR code com link curto\n\n**Página ApkUpload.tsx:**\n- Criar formulário de upload com drag-and-drop usando react-dropzone\n- Implementar validação client-side: tipo de arquivo APK, tamanho máximo\n- Seletor de tenant com busca e autocomplete\n- Campo para versão/build number com validação\n- Progress bar para upload com feedback visual\n- Integração com endpoint de upload do ApkManagementController\n\n**Página ApkStatistics.tsx:**\n- Dashboard de estatísticas com gráficos usando recharts\n- Cards de métricas: total de downloads, downloads por versão, downloads por tenant\n- Gráfico temporal de downloads (últimos 30 dias)\n- Gráfico de distribuição por tenant\n- Tabela de top downloads por player/device\n- Filtros por período e tenant\n\n**Componentes auxiliares:**\n- QrCodeModal.tsx: Modal para exibir QR code com botão de copiar link\n- ApkUploadProgress.tsx: Componente de progresso de upload\n- ApkStatsCard.tsx: Card reutilizável para métricas\n- ApkVersionBadge.tsx: Badge para exibir versão com cores por status\n\n**Integração com API:**\n- Usar rotas type-safe do Laravel Wayfinder\n- Implementar error handling e loading states\n- Toast notifications para sucesso/erro usando shadcn/ui toast",
        "testStrategy": "1. Criar testes de componente usando React Testing Library para ApkIndex, ApkUpload e ApkStatistics verificando renderização correta dos elementos\n2. Testar funcionalidade de upload: drag-and-drop, validação de arquivo, progress bar e feedback de erro\n3. Testar filtros e busca na página ApkIndex com dados mockados\n4. Verificar integração com API mockando respostas do ApkManagementController\n5. Testar modal de QR code: abertura, fechamento e funcionalidade de copiar link\n6. Validar gráficos e estatísticas com diferentes datasets\n7. Testar responsividade das páginas em dispositivos móveis e desktop\n8. Verificar acessibilidade dos formulários e tabelas\n9. Testar cenários de erro: falha no upload, API indisponível, arquivo inválido\n10. Criar testes E2E com Cypress para fluxo completo de upload e visualização",
        "status": "done",
        "dependencies": [
          17,
          15
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Criar controller PlayerController com métodos de gerenciamento para players",
        "description": "Implementar o controller PlayerController no painel do cliente com métodos completos para gerenciar players: listar, cadastrar, atualizar, deletar, ativar e configurar players Android.",
        "details": "Criar arquivo `app/Http/Controllers/PlayerController.php` usando `php artisan make:controller PlayerController --resource` com os seguintes métodos:\n\n**Método index():**\n- Listar todos os players do tenant atual com paginação\n- Incluir filtros por status (online, offline), nome e data de última atividade\n- Retornar view `client.players.index` com lista paginada\n- Aplicar TenantScope automaticamente para mostrar apenas players do tenant\n\n**Método store():**\n- Validar dados: nome, código de ativação, configurações opcionais\n- Criar novo player associado ao tenant atual\n- Gerar código de ativação único se não fornecido\n- Retornar resposta JSON ou redirect com sucesso/erro\n\n**Método update():**\n- Validar dados de atualização: nome, status, configurações\n- Atualizar player específico do tenant\n- Verificar permissões usando TenantScope\n- Retornar resposta JSON com dados atualizados\n\n**Método destroy():**\n- Deletar player específico do tenant atual\n- Verificar dependências e relacionamentos\n- Soft delete se houver histórico de logs importantes\n- Retornar confirmação de deleção\n\n**Método activate():**\n- Ativar player usando código de ativação\n- Validar código único e associar ao tenant\n- Atualizar status para ativo e registrar timestamp\n- Retornar dados de configuração inicial\n\n**Método updateSettings():**\n- Atualizar configurações específicas do player\n- Validar JSON de configurações (resolução, orientação, volume)\n- Salvar configurações no banco ou arquivo JSON\n- Notificar player das mudanças via API\n\n**Método getLogs():**\n- Retornar logs de atividade do player específico\n- Implementar paginação e filtros por data/tipo\n- Formatar logs para exibição no painel\n- Aplicar TenantScope para segurança\n\nImplementar middleware TenantScope em todas as rotas. Criar validações usando Form Requests para dados de entrada. Incluir rate limiting para métodos de ativação.",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlayerControllerTest` para verificar acesso restrito ao tenant correto\n2. Testar método `index()`: verificar paginação, filtros e aplicação do TenantScope\n3. Testar `store()`: criar player com dados válidos e inválidos, verificar geração de código de ativação\n4. Testar `update()` e `destroy()`: modificar e deletar players, verificar permissões de tenant\n5. Testar `activate()`: ativação com código válido/inválido, verificar associação ao tenant correto\n6. Testar `updateSettings()`: validar JSON de configurações e persistência\n7. Testar `getLogs()`: verificar retorno de logs paginados e filtrados por tenant\n8. Criar factory `PlayerFactory` para dados de teste\n9. Testar middleware TenantScope em todas as rotas\n10. Verificar rate limiting no método activate\n11. Testar validações de Form Request para todos os métodos",
        "status": "done",
        "dependencies": [
          1,
          13
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Criar controller MediaController para gerenciamento completo de mídia no painel do cliente",
        "description": "Implementar o controller MediaController com métodos CRUD completos, upload de arquivos, geração de thumbnails e organização por pastas/tags para gerenciamento de mídia no painel do cliente.",
        "details": "Criar arquivo `app/Http/Controllers/MediaController.php` usando `php artisan make:controller MediaController --resource` com os seguintes métodos:\n\n**Método index():**\n- Listar todas as mídias do tenant atual com paginação\n- Incluir filtros por tipo (imagem, vídeo), tags, pasta e data de upload\n- Retornar view `client.media.index` com lista paginada e thumbnails\n- Aplicar TenantScope automaticamente para mostrar apenas mídias do tenant\n- Implementar busca por nome do arquivo\n\n**Método store():**\n- Validar upload: tipos permitidos (mp4, avi, jpg, png), tamanho máximo baseado no plano\n- Salvar arquivo em storage específico do tenant\n- Gerar registro no banco com metadados: nome, tipo, tamanho, dimensões\n- Chamar método generateThumbnail() automaticamente\n- Retornar resposta JSON com dados da mídia criada\n\n**Método update():**\n- Permitir edição de nome, descrição, tags e pasta\n- Validar dados de entrada\n- Aplicar TenantScope para segurança\n- Retornar resposta JSON atualizada\n\n**Método destroy():**\n- Deletar arquivo físico do storage\n- Remover registro do banco\n- Deletar thumbnails associados\n- Verificar se mídia não está sendo usada em playlists\n\n**Método upload():**\n- Endpoint específico para upload via AJAX/Fetch\n- Suporte a upload múltiplo\n- Progress tracking\n- Validação de quota do tenant\n- Processamento assíncrono com jobs para arquivos grandes\n\n**Método generateThumbnail():**\n- Gerar thumbnails para vídeos usando FFmpeg\n- Criar thumbnails redimensionados para imagens\n- Salvar em diretório específico (/thumbnails)\n- Atualizar registro com caminho do thumbnail\n\n**Método organize():**\n- Criar/editar pastas virtuais\n- Adicionar/remover tags\n- Mover mídias entre pastas\n- Bulk operations para organização em lote",
        "testStrategy": "1. Criar teste de feature `php artisan make:test MediaControllerTest` para verificar acesso restrito ao tenant correto\n2. Testar método `index()`: verificar paginação, filtros, aplicação do TenantScope e busca\n3. Testar `store()` e `upload()`: upload de arquivos válidos e inválidos, verificar limite de quota, validação de tipos de arquivo\n4. Testar `generateThumbnail()`: verificar geração para vídeos e imagens, salvar em local correto\n5. Testar `update()`: edição de metadados, validação e aplicação do TenantScope\n6. Testar `destroy()`: remoção de arquivo físico, thumbnails e registro do banco\n7. Testar `organize()`: criação de pastas, adição de tags e movimentação de arquivos\n8. Criar dados de teste: múltiplos tenants, arquivos de mídia e verificar isolamento entre tenants\n9. Testar validação de quota: upload deve falhar quando limite do plano for atingido\n10. Criar teste de integração para pipeline completo: upload → thumbnail → organização",
        "status": "done",
        "dependencies": [
          1,
          13
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Criar controller PlaylistController com métodos completos de gerenciamento para playlists",
        "description": "Implementar o controller PlaylistController no painel do cliente com métodos CRUD completos, adição/remoção de mídia, reordenação de itens e atribuição de playlists para players específicos.",
        "details": "Criar arquivo `app/Http/Controllers/PlaylistController.php` usando `php artisan make:controller PlaylistController --resource` com os seguintes métodos:\n\n**Método index():**\n- Listar todas as playlists do tenant atual com paginação\n- Incluir filtros por nome, status (ativa, inativa) e data de criação\n- Retornar view `client.playlists.index` com lista paginada\n- Aplicar TenantScope automaticamente para mostrar apenas playlists do tenant\n- Mostrar quantidade de mídias e players atribuídos\n\n**Método store():**\n- Validar dados: nome (obrigatório, máx 255 chars), descrição (opcional), status\n- Criar nova playlist vinculada ao tenant atual\n- Retornar redirect para index com mensagem de sucesso\n- Aplicar validação de nome único por tenant\n\n**Método update():**\n- Validar dados similares ao store\n- Atualizar playlist existente do tenant\n- Verificar permissões usando TenantScope\n- Retornar redirect com feedback\n\n**Método destroy():**\n- Deletar playlist e remover associações com players\n- Verificar se playlist não está sendo usada por players ativos\n- Implementar soft delete para manter histórico\n\n**Método addMedia():**\n- Adicionar mídia específica à playlist\n- Validar se mídia pertence ao tenant\n- Definir ordem automática (último + 1)\n- Retornar JSON response para requisições AJAX\n\n**Método removeMedia():**\n- Remover mídia da playlist\n- Reorganizar ordem dos itens restantes\n- Verificar permissões de tenant\n\n**Método reorder():**\n- Receber array com nova ordem dos itens\n- Atualizar campo `order` na tabela pivot\n- Validar que todos os IDs pertencem à playlist\n\n**Método assignToPlayer():**\n- Atribuir playlist a um ou múltiplos players\n- Validar que players pertencem ao tenant\n- Criar registro na tabela `player_playlists`\n- Suporte para agendamento (opcional)",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlaylistControllerTest` para verificar acesso restrito ao tenant correto\n2. Testar método `index()`: verificar paginação, filtros e aplicação do TenantScope\n3. Testar `store()`: criar playlist com dados válidos e inválidos, verificar validação de nome único por tenant\n4. Testar `update()` e `destroy()`: modificar e deletar playlists do tenant, verificar proteção contra acesso cross-tenant\n5. Testar `addMedia()` e `removeMedia()`: adicionar/remover mídias, verificar que apenas mídias do tenant podem ser usadas\n6. Testar `reorder()`: reorganizar itens da playlist, verificar persistência da nova ordem\n7. Testar `assignToPlayer()`: atribuir playlist a players, verificar que apenas players do tenant são aceitos\n8. Criar factory `PlaylistFactory` e seeder com dados de teste\n9. Testar middleware TenantScope em todos os métodos\n10. Verificar responses JSON corretos para métodos AJAX (addMedia, removeMedia, reorder)",
        "status": "done",
        "dependencies": [
          1,
          22
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Criar controller DashboardController para dashboard do cliente com métricas",
        "description": "Implementar o controller DashboardController no painel do cliente com métodos para exibir métricas de players online/offline, storage usado, últimos conteúdos e estatísticas gerais do tenant.",
        "details": "Criar arquivo `app/Http/Controllers/DashboardController.php` usando `php artisan make:controller DashboardController` com os seguintes métodos:\n\n**Método index():**\n- Retornar view `client.dashboard` com dados do tenant atual\n- Calcular estatísticas de players: total, online (últimas 24h), offline\n- Calcular uso de storage: espaço usado, limite do plano, percentual utilizado\n- Buscar últimos 5 conteúdos/mídias adicionados com thumbnails\n- Buscar últimas 3 playlists criadas ou atualizadas\n- Incluir estatísticas de downloads de APK do tenant\n- Aplicar TenantScope automaticamente para dados do tenant\n\n**Método getMetrics():**\n- Endpoint AJAX para atualizar métricas em tempo real\n- Retornar JSON com contadores atualizados\n- Implementar cache de 5 minutos para otimizar performance\n\n**Cálculos de métricas:**\n- Players online: `Player::where('tenant_id', auth()->user()->tenant_id)->where('last_seen_at', '>=', now()->subDay())->count()`\n- Storage usado: somar tamanho de todos os arquivos de mídia do tenant\n- Últimos conteúdos: `Media::where('tenant_id', auth()->user()->tenant_id)->latest()->limit(5)->get()`\n\n**Middleware aplicado:**\n- `auth` - usuário logado\n- `tenant.scope` - dados do tenant atual apenas\n- `role:client` - apenas usuários cliente",
        "testStrategy": "1. Criar teste de feature `php artisan make:test DashboardControllerTest` para verificar acesso restrito ao tenant correto\n2. Testar método `index()`: verificar se retorna view correta com todas as métricas calculadas\n3. Criar dados de teste: players com diferentes status e `last_seen_at`, arquivos de mídia com tamanhos variados\n4. Testar cálculo de players online/offline com diferentes cenários de tempo\n5. Testar cálculo de storage usado somando tamanhos de arquivos do tenant\n6. Testar método `getMetrics()`: verificar retorno JSON com estrutura correta\n7. Testar aplicação do TenantScope: verificar que dados de outros tenants não aparecem\n8. Testar cache das métricas: verificar se dados são cacheados por 5 minutos\n9. Testar middleware de autorização: usuários admin não devem acessar, apenas clients do tenant correto",
        "status": "done",
        "dependencies": [
          1,
          9,
          22
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Criar páginas React para dashboard do cliente com cards de resumo, gráficos de players status e avisos importantes",
        "description": "Implementar páginas React completas para o dashboard do cliente com interface moderna incluindo cards de métricas, gráficos interativos de status dos players e seção de avisos importantes usando componentes shadcn/ui.",
        "details": "Criar as seguintes páginas React no diretório `resources/js/pages/client/dashboard/`:\n\n**Página Dashboard.tsx:**\n- Implementar layout principal com grid responsivo de cards de métricas usando shadcn/ui Card component\n- Criar cards de resumo: total de players, players online/offline, storage usado/disponível, últimos conteúdos\n- Implementar seção de estatísticas com ícones do Lucide React (Activity, HardDrive, Monitor, FileVideo)\n- Integrar dados do DashboardController via props do Inertia.js\n\n**Componente PlayerStatusChart.tsx:**\n- Implementar gráfico de pizza usando Recharts para visualizar status dos players (online vs offline)\n- Adicionar tooltip customizado com informações detalhadas\n- Implementar animações suaves e cores do tema (verde para online, vermelho para offline)\n- Mostrar percentuais e números absolutos\n\n**Componente StorageUsageBar.tsx:**\n- Criar barra de progresso customizada para uso de storage com gradiente de cores\n- Mostrar porcentagem usado vs disponível baseado no plano do tenant\n- Implementar alertas visuais quando próximo do limite (amarelo 80%, vermelho 90%)\n- Adicionar tooltip com detalhes em MB/GB\n\n**Componente ImportantAlerts.tsx:**\n- Implementar lista de avisos importantes com ícones de prioridade\n- Categorizar alertas: players offline há mais de 24h, storage próximo do limite, falhas de sincronização\n- Usar componentes Alert do shadcn/ui com diferentes variantes (warning, destructive, info)\n- Implementar botão para marcar avisos como lidos\n\n**Componente RecentActivity.tsx:**\n- Criar timeline de atividades recentes: novos uploads, players conectados/desconectados, playlists atualizadas\n- Usar componentes Badge para categorizar tipos de atividade\n- Implementar scroll infinito ou paginação para histórico extenso\n\n**Integração de dados:**\n- Consumir dados do DashboardController via Inertia.js props\n- Implementar type definitions TypeScript para todas as interfaces de dados\n- Adicionar loading states e error handling usando React Query ou SWR\n- Implementar refresh automático dos dados a cada 30 segundos",
        "testStrategy": "1. Criar testes de componente usando React Testing Library para Dashboard, PlayerStatusChart, StorageUsageBar e ImportantAlerts verificando renderização correta dos elementos\n2. Testar integração com dados do DashboardController: mockar props do Inertia.js e verificar se componentes exibem dados corretos\n3. Testar responsividade: verificar layout em diferentes tamanhos de tela (mobile, tablet, desktop)\n4. Testar interatividade: hover states nos gráficos, tooltips, botões de refresh e navegação\n5. Criar testes de acessibilidade verificando aria-labels, contrast ratios e navegação por teclado\n6. Testar diferentes cenários de dados: tenant com muitos players, poucos players, storage próximo do limite, sem avisos importantes\n7. Verificar integração com tema dark/light mode e se cores dos gráficos se adaptam corretamente",
        "status": "done",
        "dependencies": [
          24,
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Criar páginas React para gerenciamento de players com tabela, formulários e ativação",
        "description": "Implementar interface completa React para gerenciamento de players Android no painel do cliente, incluindo listagem com tabela, formulários de cadastro/edição, configurações individuais e sistema de ativação via token.",
        "details": "Criar as seguintes páginas React no diretório `resources/js/pages/client/players/`:\n\n**Página Index.tsx:**\n- Implementar tabela responsiva usando shadcn/ui Table component para listar players\n- Colunas: nome, código de ativação, status (online/offline com indicador visual), último acesso, ações\n- Filtros por status, busca por nome e data range picker para último acesso\n- Paginação com shadcn/ui Pagination component\n- Botões de ação: editar, configurar, deletar com confirmação via Dialog\n- Status online/offline com badges coloridos (verde/vermelho) e tooltip com última atividade\n\n**Página Create.tsx:**\n- Formulário de cadastro usando react-hook-form com validação\n- Campos: nome (obrigatório), descrição, localização, configurações iniciais\n- Geração automática de código de ativação único\n- Preview do QR Code para ativação usando biblioteca qrcode.js\n- Botão para copiar código de ativação para clipboard\n- Validação em tempo real e mensagens de erro com shadcn/ui Form components\n\n**Página Edit.tsx:**\n- Formulário de edição pré-preenchido com dados do player\n- Campos editáveis: nome, descrição, localização, configurações avançadas\n- Opção para regenerar código de ativação com confirmação\n- Seção de configurações específicas: volume padrão, tempo de sincronização, modo de exibição\n\n**Página Show.tsx:**\n- Visualização detalhada do player com cards informativos\n- Informações: status atual, última sincronização, playlists atribuídas, logs recentes\n- Gráfico de atividade das últimas 24h usando recharts\n- Seção de logs com tabela paginada de atividades\n- Botões de ação: forçar sincronização, reiniciar player (comandos remotos)\n\n**Página Activate.tsx:**\n- Interface para ativação manual de players\n- Input para código de ativação com validação\n- QR Code scanner usando biblioteca qr-scanner para ativação por câmera\n- Feedback visual de sucesso/erro na ativação\n- Lista de players pendentes de ativação\n\n**Componentes auxiliares:**\n- PlayerStatusBadge: badge colorido para status online/offline\n- PlayerConfigForm: formulário reutilizável para configurações\n- ActivationQRCode: componente para gerar e exibir QR codes\n- PlayerLogsTable: tabela paginada para logs de atividade\n\n**Integração com backend:**\n- Usar Inertia.js para comunicação com PlayerController\n- Implementar real-time updates via polling para status dos players\n- Tratamento de erros e loading states com shadcn/ui components\n- Validação client-side sincronizada com validation rules do backend",
        "testStrategy": "1. Criar testes de componente usando React Testing Library para cada página: Index, Create, Edit, Show e Activate verificando renderização correta dos elementos e interações do usuário\n2. Testar integração com PlayerController: mockar responses do Inertia.js e verificar se dados são exibidos corretamente na tabela e formulários\n3. Testar funcionalidades específicas: filtros da tabela, validação de formulários, geração de QR codes, copy to clipboard, e scanner de QR code\n4. Testar responsividade em diferentes tamanhos de tela usando viewport testing\n5. Verificar acessibilidade com screen readers e navegação por teclado\n6. Testar estados de loading, erro e sucesso nas operações CRUD\n7. Validar que apenas players do tenant atual são exibidos e manipulados\n8. Testar real-time updates do status dos players simulando mudanças de estado\n9. Verificar performance da tabela com grande quantidade de dados (100+ players)\n10. Testar integração end-to-end: criar player via formulário, ativar via QR code, editar configurações e verificar logs",
        "status": "done",
        "dependencies": [
          21,
          9,
          24
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Criar páginas React para upload e gerenciamento de mídias com drag-drop, preview, organização por pastas/tags e validação de tipos",
        "description": "Implementar interface completa React para gerenciamento de mídias no painel do cliente, incluindo upload com drag-and-drop, preview de arquivos, organização por pastas/tags, validação de tipos e interface responsiva usando shadcn/ui.",
        "details": "Criar as seguintes páginas React no diretório `resources/js/pages/client/media/`:\n\n**Página Index.tsx:**\n- Implementar grid responsivo para exibir mídias com thumbnails usando shadcn/ui Card component\n- Criar barra de ferramentas com filtros por tipo (imagem, vídeo), tags, pastas e busca por nome\n- Implementar visualização em grid/lista alternável com toggle switch\n- Adicionar botões de ação: upload, criar pasta, editar em lote, deletar selecionados\n- Integrar paginação infinita ou tradicional com shadcn/ui Pagination\n- Mostrar informações de cada mídia: nome, tamanho, tipo, data upload, tags\n\n**Página Upload.tsx:**\n- Implementar zona de drag-and-drop usando react-dropzone com feedback visual\n- Validação client-side de tipos de arquivo (imagem: jpg, png, gif; vídeo: mp4, avi, mov)\n- Validação de tamanho máximo por arquivo e total do upload\n- Preview imediato de imagens e thumbnails de vídeos antes do envio\n- Barra de progresso individual e geral usando shadcn/ui Progress component\n- Formulário para adicionar tags, pasta de destino e descrição\n- Suporte a upload múltiplo com queue de processamento\n\n**Página Show.tsx:**\n- Visualização detalhada da mídia com player integrado para vídeos\n- Exibir metadados: resolução, duração (vídeos), tamanho, formato, data criação\n- Formulário de edição inline para nome, tags, pasta e descrição\n- Botões de ação: download, deletar, duplicar, compartilhar link\n- Histórico de uso em playlists e players\n\n**Componentes auxiliares:**\n- `MediaGrid.tsx`: Grid responsivo de cards de mídia\n- `MediaCard.tsx`: Card individual com thumbnail, nome e ações\n- `UploadDropzone.tsx`: Zona drag-and-drop reutilizável\n- `MediaPreview.tsx`: Modal de preview com player de vídeo\n- `TagManager.tsx`: Componente para gerenciar tags com autocomplete\n- `FolderBrowser.tsx`: Navegador de pastas em árvore\n\n**Funcionalidades específicas:**\n- Integração com MediaController via Inertia.js para CRUD operations\n- Suporte a teclas de atalho (Ctrl+A selecionar tudo, Delete para remover)\n- Filtros persistentes na URL usando query parameters\n- Loading states e error handling com toast notifications\n- Seleção múltipla com checkbox e ações em lote\n- Organização por pastas com breadcrumb navigation",
        "testStrategy": "1. Criar testes de componente usando React Testing Library para Index, Upload, Show e componentes auxiliares verificando renderização correta dos elementos e interações do usuário\n2. Testar funcionalidade de drag-and-drop: simular eventos de drop, verificar validação de tipos de arquivo e feedback visual\n3. Testar upload de arquivos: mockar calls para MediaController, verificar progress bars e handling de erros\n4. Testar integração com MediaController: mockar responses do Inertia.js e verificar se dados são exibidos corretamente na interface\n5. Testar filtros e busca: verificar se query parameters são atualizados na URL e resultados filtrados corretamente\n6. Testar seleção múltipla e ações em lote: simular seleção de vários itens e execução de ações\n7. Testar responsividade: verificar layout em diferentes tamanhos de tela (mobile, tablet, desktop)\n8. Criar testes de integração E2E com Cypress: fluxo completo de upload, organização e gerenciamento de mídias\n9. Testar validação client-side: arquivos inválidos, tamanhos excedidos e limites do plano\n10. Verificar acessibilidade: navegação por teclado, screen readers e contraste de cores",
        "status": "done",
        "dependencies": [
          22,
          9,
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Criar páginas React para criação e edição de playlists com drag-drop para reordenar itens e configuração de tempo de exibição",
        "description": "Implementar interface completa React para gerenciamento de playlists no painel do cliente, incluindo formulários de criação/edição, drag-and-drop para reordenação de itens, configuração de tempo de exibição e interface responsiva usando shadcn/ui.",
        "details": "Criar as seguintes páginas React no diretório `resources/js/pages/client/playlists/`:\n\n**Página Index.tsx:**\n- Implementar tabela responsiva usando shadcn/ui Table component para listar playlists\n- Colunas: nome, descrição, quantidade de mídias, duração total, status (ativa/inativa), ações\n- Filtros por status, busca por nome e ordenação por data de criação\n- Botões de ação: criar nova, editar, duplicar, deletar com confirmação via Dialog\n- Status visual com Badge component (ativa=verde, inativa=cinza)\n\n**Página Create.tsx:**\n- Formulário usando shadcn/ui Form component com validação via react-hook-form e zod\n- Campos: nome (obrigatório), descrição, status inicial\n- Validação frontend: nome único, descrição opcional max 500 chars\n- Redirecionamento para página de edição após criação para adicionar mídias\n\n**Página Edit.tsx:**\n- Formulário de edição básica da playlist (nome, descrição, status)\n- Seção de gerenciamento de mídias com drag-and-drop usando @dnd-kit/sortable\n- Lista de mídias na playlist com thumbnail, nome, duração e tempo de exibição configurável\n- Input numérico para configurar tempo de exibição por mídia (segundos)\n- Botão para adicionar mídias da biblioteca com modal de seleção\n- Botão para remover mídias da playlist com confirmação\n- Preview da playlist com duração total calculada\n- Drag handles visuais e feedback durante o arraste\n- Auto-save das alterações de ordem e configurações\n\n**Componente PlaylistMediaManager.tsx:**\n- Implementar drag-and-drop para reordenação usando @dnd-kit\n- Cards de mídia com thumbnail, informações e controles de tempo\n- Input controlado para tempo de exibição com validação (min 1s, max 300s)\n- Indicadores visuais durante drag (highlight, placeholder)\n- Integração com endpoint de reordenação via Inertia.js\n\n**Componente MediaSelectionModal.tsx:**\n- Modal para seleção de mídias da biblioteca\n- Grid de mídias com checkbox para seleção múltipla\n- Filtros por tipo e busca\n- Paginação ou scroll infinito\n- Botão para adicionar selecionadas à playlist",
        "testStrategy": "1. Criar testes de componente usando React Testing Library para Index, Create, Edit e componentes auxiliares verificando renderização correta dos elementos e interações do usuário\n2. Testar funcionalidade de drag-and-drop: simular eventos de arrastar e soltar, verificar reordenação visual e chamadas para API\n3. Testar validação de formulários: dados inválidos, campos obrigatórios e feedback de erro\n4. Testar integração com PlaylistController: mockar responses do Inertia.js e verificar se dados são exibidos corretamente\n5. Testar componente MediaSelectionModal: seleção múltipla, filtros e adição de mídias\n6. Testar configuração de tempo de exibição: valores válidos/inválidos, auto-save\n7. Criar testes de integração end-to-end usando Cypress para fluxo completo: criar playlist, adicionar mídias, reordenar e configurar tempos\n8. Testar responsividade em diferentes breakpoints\n9. Validar acessibilidade: navegação por teclado, labels ARIA e screen readers",
        "status": "done",
        "dependencies": [
          23,
          27,
          11,
          12
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Criar páginas React para atribuição de playlists a players com configuração de agendamento",
        "description": "Implementar interface completa React no painel do cliente para atribuir playlists específicas a players selecionados, incluindo configuração avançada de agendamento por datas, horários e dias da semana usando componentes shadcn/ui.",
        "details": "Criar as seguintes páginas React no diretório `resources/js/pages/client/scheduling/`:\n\n**Página PlayerPlaylistAssignment.tsx:**\n- Implementar layout com duas colunas: seleção de players (esquerda) e configuração de playlist/agendamento (direita)\n- Criar componente PlayerSelector com checkboxes para múltipla seleção usando shadcn/ui Checkbox\n- Filtros por status do player (online/offline) e busca por nome\n- Indicadores visuais de status com Badge component (online=verde, offline=vermelho)\n\n**Seção de Configuração de Playlist:**\n- Dropdown para seleção de playlist usando shadcn/ui Select component\n- Preview da playlist selecionada com lista de mídias e duração total\n- Opção para criar nova playlist diretamente na interface\n\n**Seção de Agendamento Avançado:**\n- Toggle para ativar/desativar agendamento usando shadcn/ui Switch\n- DatePicker para seleção de data de início e fim usando shadcn/ui Calendar\n- TimePicker para horários de início e fim usando shadcn/ui Input com máscara\n- Checkboxes para dias da semana com shadcn/ui Checkbox (Segunda, Terça, etc.)\n- Opções de recorrência: diária, semanal, mensal usando shadcn/ui RadioGroup\n- Preview do cronograma configurado em formato de timeline\n\n**Página SchedulingIndex.tsx:**\n- Tabela de agendamentos ativos com colunas: playlist, players atribuídos, período, dias da semana, status\n- Filtros por período (hoje, próximos 7 dias, próximos 30 dias) e status (ativo, pausado, expirado)\n- Ações rápidas: editar, duplicar, pausar/retomar, deletar com confirmação\n- Indicadores de conflitos de agendamento entre playlists\n\n**Componentes Auxiliares:**\n- `SchedulePreview.tsx`: visualização do cronograma em formato de calendário\n- `PlayerStatusBadge.tsx`: badge reutilizável para status do player\n- `PlaylistPreview.tsx`: card com informações da playlist selecionada\n- `TimeRangePicker.tsx`: componente para seleção de faixa horária\n- `ConflictWarning.tsx`: alerta para conflitos de agendamento\n\n**Integração com Backend:**\n- Conectar com PlayerPlaylistController para operações CRUD de atribuições\n- Implementar validação client-side para conflitos de horário\n- Toast notifications para sucesso/erro usando shadcn/ui Sonner\n- Loading states durante operações assíncronas com shadcn/ui Skeleton",
        "testStrategy": "1. Criar testes de componente usando React Testing Library para PlayerPlaylistAssignment, SchedulingIndex e todos os componentes auxiliares verificando renderização correta e interações do usuário\n2. Testar seleção múltipla de players: simular cliques em checkboxes, verificar estado de seleção e filtros por status\n3. Testar configuração de agendamento: validar seleção de datas/horários, dias da semana e recorrência, verificar preview do cronograma\n4. Testar detecção de conflitos: criar múltiplos agendamentos sobrepostos e verificar se warnings são exibidos corretamente\n5. Testar integração com PlayerPlaylistController: mockar responses do Inertia.js para operações de atribuição, verificar se dados são enviados no formato correto\n6. Testar responsividade: verificar layout em diferentes tamanhos de tela (mobile, tablet, desktop)\n7. Testar validações: tentar criar agendamentos com dados inválidos (datas passadas, horários conflitantes) e verificar mensagens de erro\n8. Testar estados de loading e feedback visual durante operações assíncronas",
        "status": "done",
        "dependencies": [
          23,
          21,
          11,
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implementar sistema de upload de arquivos para S3/MinIO com validação e organização",
        "description": "Criar sistema completo de upload de arquivos para storage S3/MinIO com validação de MIME types, limites de tamanho por tenant e organização automática por pastas baseada em tenant e tipo de arquivo.",
        "details": "Implementar os seguintes componentes:\n\n**Configuração de Storage:**\n- Configurar driver S3 no `config/filesystems.php` com suporte a MinIO\n- Adicionar variáveis de ambiente: `S3_ENDPOINT`, `S3_BUCKET`, `S3_ACCESS_KEY_ID`, `S3_SECRET_ACCESS_KEY`\n- Configurar URL personalizada para MinIO usando `S3_URL` e `S3_USE_PATH_STYLE_ENDPOINT`\n\n**Service UploadService:**\n- Criar `app/Services/UploadService.php` com método `uploadFile($file, $tenant, $type)`\n- Implementar validação de MIME types permitidos (video/*, image/*, audio/*)\n- Verificar limites de tamanho baseado no plano do tenant (Basic: 1GB, Pro: 5GB, Enterprise: 20GB)\n- Organizar arquivos em estrutura: `/tenants/{tenant_id}/{type}/{year}/{month}/filename`\n- Gerar thumbnails automáticos para vídeos e imagens usando FFmpeg\n- Retornar dados do arquivo: path, size, mime_type, thumbnail_path\n\n**Controller FileUploadController:**\n- Criar `app/Http/Controllers/FileUploadController.php` com método `upload(Request $request)`\n- Validar arquivo usando rules customizadas baseadas no tenant\n- Integrar com UploadService para processamento\n- Criar registro na tabela media_files após upload bem-sucedido\n- Retornar resposta JSON com dados do arquivo ou erros\n\n**Middleware de Validação:**\n- Criar middleware `CheckStorageQuota` para verificar limite de storage do tenant\n- Verificar espaço disponível antes do upload\n- Retornar erro 422 se exceder quota",
        "testStrategy": "1. Criar teste de feature `php artisan make:test FileUploadTest` para testar upload completo com diferentes tipos de arquivo\n2. Testar validação de MIME types: enviar arquivos permitidos (MP4, JPG, PNG) e não permitidos (EXE, ZIP)\n3. Testar limites de tamanho: criar tenants com diferentes planos e testar uploads que excedem o limite\n4. Testar organização de pastas: verificar se arquivos são salvos na estrutura correta `/tenants/{id}/{type}/{year}/{month}/`\n5. Testar geração de thumbnails: enviar vídeo e imagem, verificar se thumbnails são gerados\n6. Testar middleware de quota: simular tenant próximo do limite e verificar bloqueio de upload\n7. Testar integração S3/MinIO: configurar bucket de teste e verificar upload real\n8. Criar teste unitário para UploadService testando cada método isoladamente",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implementar processamento de vídeos com FFmpeg em background jobs para compressão automática e geração de thumbnails",
        "description": "Criar sistema de processamento automático de vídeos usando FFmpeg em background jobs para compressão, transcodificação e geração de thumbnails após upload de arquivos de mídia.",
        "details": "Implementar os seguintes componentes:\n\n**Job de Processamento de Vídeo:**\n- Criar `app/Jobs/ProcessVideoJob.php` usando `php artisan make:job ProcessVideoJob`\n- Implementar método `handle()` que recebe MediaFile e executa processamento FFmpeg\n- Configurar timeout de 30 minutos para vídeos grandes\n- Usar `FFMpeg\\FFMpeg` package para abstração do FFmpeg\n\n**Compressão Automática:**\n- Configurar presets de compressão por tipo de arquivo (MP4, MOV, AVI)\n- Implementar compressão com qualidade baseada no plano do tenant\n- Substituir arquivo original pelo comprimido e atualizar campos `size` e `compressed_size` na tabela media_files\n- Manter proporções originais do vídeo\n\n**Geração de Thumbnails:**\n- Gerar thumbnail no segundo 1 do vídeo em formato JPG\n- Redimensionar para 320x180 pixels mantendo proporção\n- Salvar no S3/MinIO na pasta `thumbnails/` do tenant\n- Atualizar campo `thumbnail_path` no model MediaFile\n\n**Integração com UploadService:**\n- Modificar `UploadService::uploadFile()` para disparar ProcessVideoJob após upload de vídeos\n- Adicionar campo `processing_status` (pending, processing, completed, failed) na tabela media_files\n- Implementar retry automático em caso de falha no processamento\n\n**Configurações FFmpeg:**\n- Instalar FFmpeg via package manager ou container\n- Configurar caminhos em `config/app.php`\n- Definir codec H.264 para compatibilidade máxima\n- Configurar bitrate baseado no plano do tenant",
        "testStrategy": "1. Criar teste de feature `php artisan make:test VideoProcessingTest` para verificar fluxo completo de upload e processamento\n2. Testar compressão: fazer upload de vídeo grande e verificar se arquivo final tem tamanho menor mantendo qualidade\n3. Testar geração de thumbnails: verificar se thumbnail é criado no S3 e campo `thumbnail_path` é atualizado\n4. Testar diferentes formatos de vídeo (MP4, MOV, AVI) e verificar se processamento funciona corretamente\n5. Testar falhas: simular erro no FFmpeg e verificar se job entra em retry e atualiza status para 'failed'\n6. Testar timeout: usar vídeo muito grande e verificar se job respeita limite de 30 minutos\n7. Verificar se ProcessVideoJob é disparado automaticamente após upload via UploadService\n8. Testar em diferentes planos de tenant para verificar se qualidade de compressão varia conforme configurado",
        "status": "done",
        "dependencies": [
          2,
          30
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implementar geração automática de thumbnails para imagens e vídeos usando FFmpeg ou ImageMagick",
        "description": "Criar sistema automático de geração de thumbnails para arquivos de mídia carregados, integrando-se ao processo de upload e processamento existente para gerar previsualizações otimizadas.",
        "details": "Implementar os seguintes componentes:\n\n**Service ThumbnailService:**\n- Criar `app/Services/ThumbnailService.php` com método `generateThumbnail($mediaFile, $options = [])`\n- Implementar detecção automática de tipo de arquivo (imagem vs vídeo)\n- Para imagens: usar ImageMagick/Intervention Image para redimensionamento\n- Para vídeos: usar FFmpeg para extrair frame específico (padrão: segundo 1)\n- Configurar múltiplos tamanhos: pequeno (150x150), médio (300x300), grande (600x600)\n\n**Integração com ProcessVideoJob:**\n- Modificar `app/Jobs/ProcessVideoJob.php` para chamar ThumbnailService após processamento\n- Adicionar suporte a thumbnails em timestamps específicos para vídeos\n- Implementar fallback para primeiro frame se timestamp especificado falhar\n\n**Job ThumbnailGenerationJob:**\n- Criar job separado `app/Jobs/ThumbnailGenerationJob.php` para processamento assíncrono\n- Implementar retry automático em caso de falha (máximo 3 tentativas)\n- Atualizar MediaFile com caminhos dos thumbnails gerados\n\n**Configuração e Storage:**\n- Adicionar configurações em `config/media.php` para tamanhos e qualidade dos thumbnails\n- Organizar thumbnails em estrutura: `thumbnails/{tenant_id}/{media_file_id}/{size}/`\n- Implementar limpeza automática de thumbnails quando MediaFile é excluído",
        "testStrategy": "1. Criar teste de feature `php artisan make:test ThumbnailGenerationTest` para verificar geração automática após upload\n2. Testar diferentes tipos de arquivo: JPG, PNG, MP4, MOV - verificar se thumbnails são gerados corretamente\n3. Testar múltiplos tamanhos: verificar se todos os tamanhos configurados são gerados\n4. Testar integração com jobs: fazer upload e verificar se ThumbnailGenerationJob é despachado\n5. Testar casos de erro: arquivo corrompido, formato não suportado, falha de FFmpeg\n6. Verificar performance: medir tempo de geração para arquivos de diferentes tamanhos\n7. Testar limpeza: excluir MediaFile e verificar se thumbnails são removidos do storage",
        "status": "done",
        "dependencies": [
          2,
          30,
          31
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Criar PlayerApiController com endpoints para comunicação com app Android",
        "description": "Implementar controller de API REST específico para comunicação com players Android, incluindo endpoints para ativação, sincronização, heartbeat e logs com autenticação por API token.",
        "details": "Implementar os seguintes componentes:\n\n**Controller PlayerApiController:**\n- Criar `app/Http/Controllers/Api/PlayerApiController.php` usando `php artisan make:controller Api/PlayerApiController`\n- Aplicar middleware de autenticação API com verificação de token do player\n- Implementar rate limiting específico para cada endpoint\n\n**Endpoint POST /api/player/activate:**\n- Receber `activation_code` e `device_info` (modelo, versão Android, etc.)\n- Validar código de ativação e associar device ao player correspondente\n- Gerar e retornar API token único para autenticação futura\n- Atualizar status do player para 'active' e registrar first_activated_at\n\n**Endpoint GET/POST /api/player/sync:**\n- Retornar configurações atuais: playlists ativas, agendamentos, configurações de display\n- Incluir URLs de download de mídias e metadados (duração, tipo, thumbnails)\n- Implementar versionamento para sincronização incremental\n- Registrar timestamp de última sincronização\n\n**Endpoint POST /api/player/heartbeat:**\n- Receber status atual: playlist em execução, mídia atual, tempo de reprodução\n- Atualizar last_seen_at, status operacional e métricas de performance\n- Retornar comandos pendentes (restart, update_playlist, etc.)\n- Implementar detecção de players offline baseada em intervalo de heartbeat\n\n**Endpoint POST /api/player/logs:**\n- Receber logs do player (errors, warnings, info) em formato estruturado\n- Salvar logs usando model PlayerLog com relacionamento ao Player\n- Implementar níveis de log e filtragem por severidade\n- Suporte a envio batch de múltiplos logs\n\n**Middleware ApiPlayerAuth:**\n- Criar middleware personalizado para autenticação via API token\n- Validar token e carregar Player correspondente no request\n- Aplicar TenantScope baseado no tenant do player\n\n**Rotas API:**\n- Definir rotas em `routes/api.php` com prefixo `/api/player/`\n- Aplicar middleware de rate limiting diferenciado por endpoint\n- Configurar CORS para permitir requisições dos players Android",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlayerApiControllerTest` para verificar todos os endpoints com diferentes cenários de autenticação e dados\n2. Testar endpoint `/activate`: tentar ativação com código válido/inválido, verificar geração de token e atualização de status do player\n3. Testar endpoint `/sync`: verificar retorno de playlists e configurações corretas para o tenant do player, testar sincronização incremental\n4. Testar endpoint `/heartbeat`: simular heartbeats regulares e verificar atualização de last_seen_at, testar detecção de players offline\n5. Testar endpoint `/logs`: enviar logs de diferentes níveis e verificar salvamento correto no banco com relacionamento ao player\n6. Testar middleware ApiPlayerAuth: verificar autenticação com token válido/inválido e aplicação correta do TenantScope\n7. Testar rate limiting: simular múltiplas requisições e verificar aplicação dos limites configurados\n8. Usar Postman ou similar para testar integração completa simulando comportamento do app Android",
        "status": "done",
        "dependencies": [
          9,
          21
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Implementar endpoint /api/player/activate para ativação via token com retorno de configurações iniciais e playlist padrão",
        "description": "Criar endpoint REST para ativação de players Android usando token único, retornando configurações de tenant, informações do player e playlist padrão para inicialização do dispositivo.",
        "details": "Implementar os seguintes componentes:\n\n**Rota API:**\n- Adicionar em `routes/api.php`: `POST /api/player/activate`\n- Criar `app/Http/Controllers/Api/PlayerController.php` com método `activate()`\n- Implementar middleware de autenticação via token Bearer ou API key\n\n**Validação e Autenticação:**\n- Validar token de ativação único enviado no request\n- Verificar se token está vinculado a um tenant válido e ativo\n- Implementar rate limiting para prevenir ataques de força bruta\n- Registrar tentativas de ativação (sucesso/falha) para auditoria\n\n**Response com Configurações:**\n- Retornar dados do tenant: nome, configurações de tema, logo\n- Incluir configurações de player: intervalo de sync, qualidade de vídeo padrão\n- Buscar playlist padrão do tenant (is_default=true) com seus media files\n- Estruturar response JSON com: tenant_config, player_settings, default_playlist\n\n**Registro do Player:**\n- Criar ou atualizar registro na tabela players com dados do dispositivo\n- Armazenar informações como: device_id, last_activation, IP address\n- Implementar lógica para identificar players únicos por device_id",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlayerActivationTest` para testar fluxo completo de ativação\n2. Testar autenticação: enviar requests com tokens válidos e inválidos, verificar responses apropriadas\n3. Testar retorno de dados: verificar se response inclui configurações de tenant, settings de player e playlist padrão\n4. Testar rate limiting: fazer múltiplas tentativas de ativação e verificar se throttling funciona\n5. Testar registro de player: verificar se dados do dispositivo são salvos corretamente na base de dados\n6. Usar Postman ou similar para testar endpoint manualmente com diferentes cenários\n7. Verificar logs de ativação e auditoria para troubleshooting",
        "status": "done",
        "dependencies": [
          2,
          3,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implementar endpoint /api/player/sync para sincronização de playlists, mídias e configurações",
        "description": "Criar endpoint REST API completo para sincronização de dados entre players Android e servidor, incluindo playlists, arquivos de mídia, configurações e verificação de updates baseada em timestamps.",
        "details": "Implementar os seguintes componentes:\n\n**Controller PlayerSyncController:**\n- Criar `app/Http/Controllers/Api/PlayerSyncController.php` com método `sync(Request $request)`\n- Implementar autenticação via token/código de ativação do player\n- Validar parâmetros: `player_code`, `last_sync_timestamp`, `current_version`\n- Retornar payload JSON com playlists atualizadas, mídias modificadas e configurações\n\n**Service PlayerSyncService:**\n- Criar `app/Services/PlayerSyncService.php` com método `getSyncData($player, $lastSync)`\n- Implementar lógica de comparação de timestamps para updates incrementais\n- Gerar URLs temporárias para download de mídias usando signed URLs (S3/MinIO)\n- Incluir verificação de versão APK e flag para forçar atualização\n\n**Estrutura da Response:**\n```json\n{\n  \"status\": \"success\",\n  \"last_sync\": \"2024-01-15T10:30:00Z\",\n  \"force_update\": false,\n  \"latest_apk_version\": \"1.2.0\",\n  \"playlists\": [\n    {\n      \"id\": 1,\n      \"name\": \"Playlist Principal\",\n      \"loop_enabled\": true,\n      \"items\": [\n        {\n          \"media_file_id\": 123,\n          \"filename\": \"video1.mp4\",\n          \"download_url\": \"https://signed-url\",\n          \"duration\": 30,\n          \"checksum\": \"md5hash\"\n        }\n      ]\n    }\n  ],\n  \"deleted_files\": [456],\n  \"player_settings\": {\n    \"volume\": 80,\n    \"brightness\": 100,\n    \"auto_restart_time\": \"03:00\"\n  }\n}\n```\n\n**Route Registration:**\n- Adicionar rota em `routes/api.php`: `Route::post('/player/sync', [PlayerSyncController::class, 'sync'])`\n- Implementar middleware de autenticação específico para players\n- Configurar rate limiting para evitar spam\n\n**Otimizações de Performance:**\n- Implementar cache Redis para dados de sincronização frequentemente acessados\n- Usar eager loading para relacionamentos (playlist->items->mediaFile)\n- Implementar compressão gzip para respostas grandes",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlayerSyncApiTest` para testar fluxo completo de sincronização\n2. Testar autenticação: enviar requests com códigos válidos e inválidos, verificar respostas adequadas\n3. Testar sincronização incremental: criar cenários com diferentes timestamps e verificar se apenas dados modificados são retornados\n4. Testar performance: criar tenant com 100+ mídias e verificar se response é gerada em menos de 2 segundos\n5. Testar signed URLs: verificar se URLs geradas permitem download das mídias e expiram corretamente\n6. Testar casos extremos: player sem playlists, tenant sem mídias, sincronização inicial vs. incremental\n7. Usar Postman/Insomnia para testar manualmente diferentes cenários de sincronização\n8. Verificar logs de sincronização e debugging para troubleshooting de problemas em produção",
        "status": "done",
        "dependencies": [
          2,
          3,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implementar endpoint /api/player/heartbeat para atualização de status online e monitoramento de players",
        "description": "Criar endpoint REST API para players Android enviarem heartbeats periódicos com informações de status, IP, versão do app e logs básicos para monitoramento em tempo real.",
        "details": "Implementar os seguintes componentes:\n\n**Controller PlayerHeartbeatController:**\n- Criar `app/Http/Controllers/Api/PlayerHeartbeatController.php` com método `heartbeat(Request $request)`\n- Implementar autenticação via token/código de ativação do player\n- Validar parâmetros: `player_code`, `app_version`, `ip_address`, `status`, `logs` (opcional)\n- Atualizar timestamp `last_seen_at` e informações do player no banco\n- Retornar resposta JSON com status de confirmação e eventuais comandos pendentes\n\n**Service PlayerHeartbeatService:**\n- Criar `app/Services/PlayerHeartbeatService.php` com método `processHeartbeat($playerCode, $data)`\n- Implementar lógica para atualizar status do player: online/offline baseado em heartbeat\n- Registrar logs básicos enviados pelo player (erros, warnings)\n- Verificar se existem comandos pendentes para o player (restart, update, sync)\n- Implementar detecção de mudança de IP e notificação\n\n**Model Player (atualização):**\n- Adicionar campos: `last_heartbeat_at`, `current_ip`, `app_version`, `status` (online/offline/error)\n- Implementar scope `online()` para filtrar players ativos\n- Método `isOnline()` baseado em timestamp do último heartbeat (< 5 minutos)\n\n**Middleware de Rate Limiting:**\n- Configurar rate limiting específico para heartbeats (máximo 1 por minuto por player)\n- Implementar throttling em `app/Http/Kernel.php` para rota heartbeat\n\n**Job para Detecção de Players Offline:**\n- Criar `app/Jobs/DetectOfflinePlayersJob.php` para executar periodicamente\n- Marcar players como offline se não enviaram heartbeat nos últimos 5 minutos\n- Enviar notificações/alertas quando player fica offline",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlayerHeartbeatApiTest` para testar endpoint completo\n2. Testar autenticação: enviar heartbeats com códigos válidos e inválidos, verificar respostas adequadas\n3. Testar atualização de status: simular heartbeats periódicos e verificar se player fica marcado como online\n4. Testar detecção offline: parar heartbeats e verificar se player é marcado como offline após timeout\n5. Testar rate limiting: enviar múltiplos heartbeats rapidamente e verificar se throttling funciona\n6. Testar logs: enviar heartbeat com logs de erro e verificar se são registrados corretamente\n7. Testar mudança de IP: enviar heartbeats com IPs diferentes e verificar detecção\n8. Criar teste unitário para PlayerHeartbeatService verificando lógica de processamento\n9. Testar job DetectOfflinePlayersJob com dados mock verificando marcação offline\n10. Verificar performance com múltiplos players enviando heartbeats simultaneamente",
        "status": "done",
        "dependencies": [
          5
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Criar middleware TenantStorageLimit para verificar limites de armazenamento antes de uploads",
        "description": "Implementar middleware que verifica automaticamente os limites de armazenamento do plano do tenant antes de permitir uploads de arquivos, bloqueando operações que excedam a cota disponível.",
        "details": "Implementar os seguintes componentes:\n\n**Middleware TenantStorageLimit:**\n- Criar `app/Http/Middleware/TenantStorageLimit.php` usando `php artisan make:middleware TenantStorageLimit`\n- Implementar método `handle(Request $request, Closure $next)` que intercepta requests de upload\n- Calcular uso atual de armazenamento do tenant consultando tabela `media_files` e somando campo `file_size`\n- Obter limite do plano atual do tenant através do relacionamento `Tenant->subscription->plan`\n- Verificar se upload atual + uso existente excede limite do plano\n- Retornar erro 413 (Payload Too Large) com mensagem específica se exceder limite\n\n**Integração com Rotas:**\n- Aplicar middleware em rotas de upload: `Route::post('/upload', [MediaController::class, 'upload'])->middleware('tenant.storage.limit')`\n- Registrar middleware em `app/Http/Kernel.php` na seção `$routeMiddleware`\n- Aplicar também em endpoints de API para players: `/api/media/upload`\n\n**Service StorageCalculatorService:**\n- Criar `app/Services/StorageCalculatorService.php` para centralizar cálculos de armazenamento\n- Método `getCurrentUsage(Tenant $tenant)` retornando bytes utilizados\n- Método `getAvailableSpace(Tenant $tenant)` retornando espaço disponível\n- Método `canUpload(Tenant $tenant, $fileSize)` para verificação prévia\n- Implementar cache Redis para otimizar consultas frequentes de uso\n\n**Configuração e Mensagens:**\n- Adicionar configurações em `config/tenant.php` para limites padrão por plano\n- Criar mensagens de erro personalizadas em `resources/lang/pt_BR/storage.php`\n- Implementar logs de tentativas de upload bloqueadas para auditoria",
        "testStrategy": "1. Criar teste de feature `php artisan make:test TenantStorageLimitMiddlewareTest` para verificar comportamento do middleware em diferentes cenários\n2. Testar upload dentro do limite: tenant com 100MB usados e limite 1GB, fazer upload de 50MB - deve permitir\n3. Testar upload que excede limite: tenant com 950MB usados e limite 1GB, fazer upload de 100MB - deve bloquear com erro 413\n4. Testar cálculo de armazenamento: criar registros de mídia com tamanhos conhecidos, verificar se cálculo está correto\n5. Testar diferentes tipos de plano: verificar se limites são aplicados corretamente conforme plano do tenant\n6. Testar middleware em rotas API: simular uploads via API de players e verificar se middleware é aplicado\n7. Criar teste unitário para StorageCalculatorService verificando precisão dos cálculos\n8. Testar performance: verificar se consultas não impactam significativamente tempo de response\n9. Testar cenários edge case: tenant sem plano, plano sem limite definido, arquivos corrompidos",
        "status": "done",
        "dependencies": [
          1,
          2,
          30
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Criar middleware PlayerLimit para verificar limites de players por tenant",
        "description": "Implementar middleware que verifica automaticamente os limites de players do plano do tenant antes de permitir cadastro de novos dispositivos, bloqueando operações que excedam a cota disponível.",
        "details": "Implementar os seguintes componentes:\n\n**Middleware PlayerLimit:**\n- Criar `app/Http/Middleware/PlayerLimit.php` usando `php artisan make:middleware PlayerLimit`\n- Implementar método `handle(Request $request, Closure $next)` que intercepta requests de cadastro de player\n- Contar players ativos do tenant consultando tabela `players` com `tenant_id` e `status = 'active'`\n- Obter limite do plano atual do tenant através do relacionamento `Tenant->subscription->plan->player_limit`\n- Verificar se cadastro excederia limite: `current_count >= player_limit`\n- Retornar erro 403 com mensagem personalizada se limite for excedido\n- Incluir informações sobre uso atual e limite no response de erro\n\n**Aplicação do Middleware:**\n- Registrar middleware no `app/Http/Kernel.php` como `player.limit`\n- Aplicar nas rotas de cadastro: `Route::post('/players', [PlayerController::class, 'store'])->middleware('player.limit')`\n- Aplicar também no endpoint de ativação de API: `Route::post('/api/player/activate')->middleware('player.limit')`\n\n**Configurações de Plano:**\n- Verificar se campo `player_limit` existe na tabela `plans` (adicionar migration se necessário)\n- Implementar método `hasReachedPlayerLimit()` no model Tenant\n- Criar helper `getRemainingPlayerSlots()` para retornar slots disponíveis",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlayerLimitMiddlewareTest` para verificar comportamento do middleware em diferentes cenários\n2. Testar cadastro dentro do limite: tenant com 5 players e limite 10, tentar cadastrar novo - deve permitir\n3. Testar cadastro que excede limite: tenant com 10 players e limite 10, tentar cadastrar - deve bloquear com erro 403\n4. Testar tenant sem limite definido: verificar se permite cadastro ilimitado ou aplica limite padrão\n5. Testar aplicação em rotas: verificar se middleware é executado em `/players` e `/api/player/activate`\n6. Testar response de erro: verificar se inclui informações sobre uso atual e limite máximo\n7. Testar contagem correta: criar players com diferentes status e verificar se conta apenas ativos\n8. Testar método `hasReachedPlayerLimit()` no model Tenant com diferentes cenários de uso",
        "status": "done",
        "dependencies": [
          1,
          2,
          9,
          21
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Criar job ProcessVideoFile para compressão de vídeos com FFmpeg em background",
        "description": "Implementar job assíncrono para processamento de vídeos usando FFmpeg, incluindo compressão, atualização de status em tempo real e sistema de notificações de conclusão para usuários.",
        "details": "Implementar os seguintes componentes:\n\n**Job ProcessVideoFile:**\n- Criar `app/Jobs/ProcessVideoFile.php` usando `php artisan make:job ProcessVideoFile`\n- Implementar método `handle()` que recebe MediaFile model como parâmetro\n- Configurar timeout de 30 minutos e 3 tentativas em caso de falha\n- Atualizar status do arquivo para 'processing' antes de iniciar\n- Usar FFmpeg para compressão: `ffmpeg -i input.mp4 -c:v libx264 -crf 23 -c:a aac -b:a 128k output.mp4`\n- Gerar thumbnail automaticamente: `ffmpeg -i input.mp4 -ss 00:00:01 -vframes 1 thumbnail.jpg`\n- Atualizar campos `processed_at`, `file_size`, `duration`, `thumbnail_path` no modelo MediaFile\n- Implementar rollback em caso de erro (remover arquivos temporários)\n\n**Sistema de Notificações:**\n- Implementar `app/Notifications/VideoProcessingCompleted.php` para notificar usuário via email\n- Criar `app/Notifications/VideoProcessingFailed.php` para falhas de processamento\n- Adicionar suporte a notificações em tempo real via broadcast (WebSockets) se disponível\n\n**Configurações FFmpeg:**\n- Criar config `config/media.php` com parâmetros de compressão personalizáveis\n- Implementar verificação de instalação do FFmpeg no sistema\n- Adicionar logs detalhados do processo usando Laravel Log facade\n- Implementar cleanup automático de arquivos temporários\n\n**Integration com Storage:**\n- Processar arquivo original do storage configurado (local/S3)\n- Salvar arquivo comprimido no mesmo storage com sufixo '_compressed'\n- Manter arquivo original como backup (configurável)\n- Implementar verificação de espaço disponível antes do processamento",
        "testStrategy": "1. Criar teste de unit `php artisan make:test ProcessVideoFileJobTest` para testar job isoladamente\n2. Testar processamento bem-sucedido: criar arquivo de vídeo de teste, disparar job e verificar se arquivo comprimido é gerado corretamente\n3. Testar atualização de status: verificar se status muda para 'processing' durante execução e 'completed' após sucesso\n4. Testar geração de thumbnail: verificar se thumbnail é criado automaticamente com dimensões corretas\n5. Testar falhas: simular erro de FFmpeg e verificar se status muda para 'failed' e notificação de erro é enviada\n6. Testar timeout: criar cenário com arquivo muito grande e verificar se job falha apropriadamente após timeout\n7. Testar notificações: verificar se emails de conclusão e falha são enviados corretamente\n8. Testar cleanup: verificar se arquivos temporários são removidos em casos de sucesso e falha\n9. Criar teste de integração para verificar fluxo completo desde upload até notificação\n10. Testar com diferentes formatos de vídeo (MP4, AVI, MOV) e verificar compatibilidade",
        "status": "done",
        "dependencies": [
          30
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Criar job GenerateThumbnail para criação de thumbnails de vídeos e imagens em background",
        "description": "Implementar job assíncrono para geração automática de thumbnails de vídeos e imagens em múltiplos tamanhos (small, medium, large) usando FFmpeg e processamento de imagem.",
        "details": "Implementar os seguintes componentes:\n\n**Job GenerateThumbnail:**\n- Criar `app/Jobs/GenerateThumbnail.php` usando `php artisan make:job GenerateThumbnail`\n- Implementar método `handle()` que recebe MediaFile model como parâmetro\n- Configurar timeout de 10 minutos e 3 tentativas em caso de falha\n- Definir tamanhos: small (150x150), medium (300x300), large (600x600)\n- Para vídeos: usar FFmpeg `ffmpeg -i input.mp4 -ss 00:00:01 -vframes 1 -q:v 2 -vf scale=150:150 thumb_small.jpg`\n- Para imagens: usar Intervention Image ou GD para redimensionamento\n- Salvar thumbnails em storage/app/public/thumbnails/{media_id}/\n- Atualizar campos `thumbnail_small`, `thumbnail_medium`, `thumbnail_large` na tabela media_files\n- Implementar tratamento de erros e logs detalhados\n- Disparar evento ThumbnailGenerated após conclusão\n\n**Migration para campos de thumbnail:**\n- Adicionar colunas `thumbnail_small`, `thumbnail_medium`, `thumbnail_large` na tabela `media_files`\n- Indexar por `media_type` para otimizar consultas\n\n**Event ThumbnailGenerated:**\n- Criar evento para notificar conclusão da geração de thumbnails\n- Incluir informações do arquivo e paths dos thumbnails gerados",
        "testStrategy": "1. Criar teste de unit `php artisan make:test GenerateThumbnailJobTest` para testar job isoladamente\n2. Testar geração para vídeos: criar arquivo de vídeo de teste, disparar job e verificar se thumbnails são gerados nos 3 tamanhos\n3. Testar geração para imagens: usar diferentes formatos (jpg, png, gif) e verificar redimensionamento correto\n4. Testar falha de processamento: simular arquivo corrompido e verificar se job falha graciosamente\n5. Testar atualização do banco: verificar se campos thumbnail_* são populados corretamente após processamento\n6. Testar integração com storage: verificar se arquivos são salvos nas pastas corretas\n7. Criar teste de feature para verificar disparo automático do job após upload de mídia",
        "status": "done",
        "dependencies": [
          30,
          39
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Criar job CheckPlayerStatus para verificar players offline e enviar alertas por email",
        "description": "Implementar job assíncrono que verifica periodicamente players offline há mais tempo que o configurado e envia alertas por email para administradores do tenant.",
        "details": "Implementar os seguintes componentes:\n\n**Job CheckPlayerStatus:**\n- Criar `app/Jobs/CheckPlayerStatus.php` usando `php artisan make:job CheckPlayerStatus`\n- Implementar método `handle()` que busca todos os players com `last_seen_at` anterior ao timeout configurado\n- Definir timeout padrão de 5 minutos (configurável via config ou tenant)\n- Filtrar apenas players com status 'active' e que não foram notificados recentemente\n- Para cada player offline encontrado, criar registro em tabela `player_alerts` com timestamp\n- Enviar email usando Mailable `PlayerOfflineAlert` para usuários admin do tenant\n- Implementar throttling para evitar spam: máximo 1 alerta por player a cada 30 minutos\n- Usar queue 'alerts' com prioridade baixa para não impactar performance\n\n**Configuração de Schedule:**\n- Adicionar em `app/Console/Kernel.php` agendamento a cada 2 minutos: `$schedule->job(CheckPlayerStatus::class)->everyTwoMinutes()`\n- Configurar timeout de 3 minutos para o job\n- Implementar flag `--force` para execução manual ignorando throttling\n\n**Mailable PlayerOfflineAlert:**\n- Criar `app/Mail/PlayerOfflineAlert.php` com informações do player offline\n- Template com nome do player, último heartbeat, localização e link para painel\n- Subject personalizado: \"[{tenant}] Player '{player_name}' está offline\"",
        "testStrategy": "1. Criar teste de unit `php artisan make:test CheckPlayerStatusJobTest` para testar job isoladamente\n2. Testar detecção de players offline: criar players com diferentes valores de `last_seen_at`, executar job e verificar quais são detectados como offline\n3. Testar throttling de alertas: executar job múltiplas vezes em sequência e verificar se apenas um alerta é enviado por player no período configurado\n4. Testar envio de emails: usar Mail::fake() para verificar se emails são enviados corretamente com dados corretos do player\n5. Testar filtros por tenant: criar players de diferentes tenants offline e verificar se alertas são enviados apenas para usuários corretos\n6. Testar agendamento: usar `php artisan schedule:run` para verificar se job é executado automaticamente\n7. Testar comando manual: executar `php artisan queue:work` e verificar logs de execução do job",
        "status": "done",
        "dependencies": [
          9,
          36,
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Criar controller PlanController com métodos para definir limites de players e storage por tenant baseado no plano ativo",
        "description": "Implementar o controller PlanController para gerenciar limites de players e storage por tenant com base no plano ativo, incluindo validações e aplicação de restrições em tempo real.",
        "details": "Criar arquivo `app/Http/Controllers/PlanController.php` usando `php artisan make:controller PlanController` com os seguintes métodos:\n\n**Método index():**\n- Listar todos os planos disponíveis com suas características\n- Retornar view `admin.plans.index` com lista de planos e limites configurados\n- Incluir informações de tenants ativos por plano\n\n**Método store():**\n- Criar novo plano com validação de nome único, limites de players e storage\n- Validar que limites sejam números positivos\n- Definir valores padrão: player_limit (default: 1), storage_limit_gb (default: 1)\n\n**Método update():**\n- Atualizar limites de plano existente\n- Validar que novos limites não sejam menores que uso atual dos tenants\n- Aplicar mudanças imediatamente aos tenants com este plano\n\n**Método applyLimits($tenantId):**\n- Aplicar limites do plano ativo ao tenant específico\n- Verificar se tenant não excede novos limites antes de aplicar\n- Retornar erro se tenant já excede limites propostos\n\n**Método checkLimits($tenantId):**\n- Verificar se tenant está dentro dos limites do seu plano\n- Retornar dados: players_used, player_limit, storage_used_gb, storage_limit_gb\n- Calcular percentuais de uso para exibição em dashboards\n\n**Service PlanLimitService:**\n- Criar `app/Services/PlanLimitService.php` para lógica de negócio\n- Método `canAddPlayer($tenant)`: verificar se pode adicionar novo player\n- Método `canUploadFile($tenant, $fileSize)`: verificar se pode fazer upload\n- Método `calculateStorageUsage($tenant)`: calcular storage usado pelo tenant",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlanControllerTest` para verificar acesso restrito a usuários admin\n2. Testar método `index()`: verificar se retorna lista correta de planos com informações de limites\n3. Testar `store()`: criar plano com dados válidos e inválidos, verificar validação de limites positivos\n4. Testar `update()`: atualizar limites e verificar se são aplicados aos tenants imediatamente\n5. Testar `applyLimits()`: aplicar limites a tenant que está dentro/fora dos novos limites\n6. Testar `checkLimits()`: verificar cálculo correto de uso vs limites para diferentes cenários\n7. Criar teste unitário `php artisan make:test PlanLimitServiceTest` para testar PlanLimitService\n8. Testar `canAddPlayer()`: cenários onde tenant pode/não pode adicionar player\n9. Testar `canUploadFile()`: upload que excede/não excede limite de storage\n10. Testar `calculateStorageUsage()`: cálculo correto do storage usado por tenant",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "Implementar lógica de verificação de limites nos controllers de Player e Media",
        "description": "Criar validações de limites de players e armazenamento nos controllers PlayerController e MediaController com mensagens de erro apropriadas quando os limites do plano forem excedidos.",
        "details": "Implementar os seguintes componentes:\n\n**PlayerController - Validação de Limites:**\n- Modificar método `store()` em `app/Http/Controllers/PlayerController.php` para verificar limites antes de criar novo player\n- Contar players ativos do tenant: `$activePlayersCount = $tenant->players()->where('status', 'active')->count()`\n- Obter limite do plano: `$playerLimit = $tenant->subscription->plan->player_limit`\n- Verificar se `$activePlayersCount >= $playerLimit` e retornar erro 422 com mensagem: \"Limite de players atingido. Plano atual permite {$playerLimit} players ativos.\"\n- Incluir link para upgrade de plano na resposta de erro\n\n**MediaController - Validação de Storage:**\n- Modificar método `store()` em `app/Http/Controllers/MediaController.php` para verificar limites antes de upload\n- Calcular uso atual: `$currentUsage = $tenant->mediaFiles()->sum('file_size')`\n- Obter limite do plano: `$storageLimit = $tenant->subscription->plan->storage_limit_gb * 1024 * 1024 * 1024`\n- Verificar se `($currentUsage + $fileSize) > $storageLimit` e retornar erro 422\n- Mensagem de erro: \"Limite de armazenamento excedido. Plano atual: {$storageLimit}GB, Uso atual: {$currentUsage}GB, Arquivo: {$fileSize}MB\"\n\n**Helper Methods:**\n- Criar método `checkPlayerLimit()` em PlayerController para reutilização\n- Criar método `checkStorageLimit($fileSize)` em MediaController\n- Implementar formatação de tamanhos para exibição amigável (MB, GB)\n- Adicionar links para upgrade de plano nas mensagens de erro",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlayerLimitValidationTest` para testar validação de limites de players\n2. Testar cenário dentro do limite: tenant com 3 players e limite 5, criar novo player - deve permitir\n3. Testar cenário que excede limite: tenant com 5 players e limite 5, tentar criar novo - deve retornar erro 422\n4. Criar teste de feature `php artisan make:test MediaStorageLimitTest` para testar validação de storage\n5. Testar upload dentro do limite: tenant com 500MB usados e limite 1GB, upload de 200MB - deve permitir\n6. Testar upload que excede limite: tenant com 800MB usados e limite 1GB, upload de 300MB - deve retornar erro 422\n7. Verificar mensagens de erro contêm informações corretas de limite, uso atual e sugestão de upgrade\n8. Testar com diferentes tipos de planos e limites configurados\n9. Verificar se validações não afetam operações de edição/atualização, apenas criação de novos recursos",
        "status": "done",
        "dependencies": [
          1,
          2,
          38,
          37
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Criar controller ContentModuleController para ativar/desativar módulos automáticos",
        "description": "Implementar o controller ContentModuleController para gerenciar a ativação e desativação de módulos de conteúdo automático (clima, cotações, frases) por tenant no painel do cliente.",
        "details": "Criar arquivo `app/Http/Controllers/ContentModuleController.php` usando `php artisan make:controller ContentModuleController` com os seguintes métodos:\n\n**Método index():**\n- Listar todos os módulos de conteúdo disponíveis com status atual para o tenant\n- Retornar view `client.content-modules.index` com configurações atuais\n- Exibir módulos: clima, cotações (câmbio), frases motivacionais\n- Mostrar status ativo/inativo e última atualização dos dados\n\n**Método update():**\n- Receber dados via PATCH para ativar/desativar módulos específicos\n- Validar que apenas módulos válidos sejam alterados: ['weather', 'quotes', 'motivational_phrases']\n- Atualizar tabela `tenant_content_modules` com novos status\n- Aplicar TenantScope para garantir que apenas o tenant atual seja afetado\n- Retornar resposta JSON com status atualizado\n\n**Método show($module):**\n- Exibir configurações específicas de um módulo\n- Permitir configuração de parâmetros como cidade para clima, moedas para cotações\n- Retornar view `client.content-modules.show` com formulário de configuração\n\n**Estrutura de dados:**\n- Utilizar tabela `tenant_content_modules` com campos: tenant_id, module_name, is_active, settings (JSON), updated_at\n- Criar enum para módulos disponíveis: WeatherModule, CurrencyModule, MotivationalModule\n- Implementar middleware TenantScope para isolamento de dados",
        "testStrategy": "1. Criar teste de feature `php artisan make:test ContentModuleControllerTest` para verificar acesso restrito ao tenant correto\n2. Testar método `index()`: verificar se retorna view correta com módulos do tenant e aplicação do TenantScope\n3. Testar método `update()`: ativar/desativar módulos com dados válidos e inválidos, verificar persistência na base de dados\n4. Testar `show()`: verificar exibição de configurações específicas de cada módulo\n5. Criar factory `TenantContentModuleFactory` para dados de teste\n6. Testar isolamento entre tenants: verificar que tenant A não pode alterar módulos do tenant B\n7. Testar validação de módulos: tentar ativar módulo inexistente deve retornar erro 422\n8. Testar resposta AJAX: verificar que método `update()` retorna JSON válido com status atualizado\n9. Criar teste de integração para verificar que módulos ativos aparecem corretamente no dashboard",
        "status": "done",
        "dependencies": [
          1,
          24
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Implementar integração com API de clima para exibição automática de previsão do tempo configurável por player",
        "description": "Criar sistema de conteúdo automático que integra com APIs de clima (OpenWeatherMap, WeatherAPI) para exibir previsão do tempo em players, com configurações específicas por dispositivo e cache para otimização.",
        "details": "Implementar os seguintes componentes:\n\n**Service WeatherService:**\n- Criar `app/Services/WeatherService.php` com métodos para integração com APIs de clima\n- Implementar suporte para múltiplas APIs: OpenWeatherMap, WeatherAPI, AccuWeather\n- Configurar fallback entre APIs em caso de falha\n- Implementar cache Redis com TTL de 15 minutos para reduzir requests\n- Método `getCurrentWeather($location)` e `getForecast($location, $days = 5)`\n\n**Model WeatherConfig:**\n- Criar migration para tabela `weather_configs` com campos: `player_id`, `api_provider`, `location`, `display_format`, `update_interval`, `show_forecast_days`\n- Criar model `app/Models/WeatherConfig.php` com relacionamento `belongsTo(Player::class)`\n- Implementar validação de localização (city, coordinates, postal code)\n\n**Job UpdateWeatherData:**\n- Criar `app/Jobs/UpdateWeatherData.php` para atualização automática dos dados de clima\n- Configurar execução a cada 15 minutos via cron job\n- Buscar todos os players com configuração de clima ativa\n- Atualizar cache com dados mais recentes de cada localização\n- Implementar throttling para evitar excesso de requests às APIs\n\n**API Endpoints:**\n- Adicionar endpoint `GET /api/player/{code}/weather` para players consumirem dados\n- Implementar `POST /api/admin/players/{id}/weather-config` para configuração\n- Retornar dados formatados conforme configuração do player\n\n**Interface Admin:**\n- Criar página de configuração de clima em `resources/js/pages/Admin/Players/WeatherConfig.tsx`\n- Formulário para selecionar API provider, localização, formato de exibição\n- Preview em tempo real dos dados de clima\n- Configuração de intervalo de atualização (5min, 15min, 30min, 1h)",
        "testStrategy": "1. Criar teste de unit `php artisan make:test WeatherServiceTest` para testar integração com diferentes APIs de clima\n2. Testar fallback entre APIs: simular falha da API principal e verificar se fallback funciona\n3. Testar cache: verificar se dados são armazenados corretamente no Redis com TTL apropriado\n4. Criar teste de feature `php artisan make:test WeatherConfigTest` para testar CRUD de configurações\n5. Testar job UpdateWeatherData: criar players com configurações diferentes, executar job e verificar atualização de dados\n6. Testar endpoint de player: simular requests de diferentes players e verificar retorno de dados específicos\n7. Testar diferentes formatos de localização: cidade, coordenadas, CEP\n8. Testar throttling: executar múltiplas requests simultâneas e verificar se rate limiting funciona\n9. Testar interface admin: verificar se configurações são salvas corretamente e preview funciona",
        "status": "done",
        "dependencies": [
          5,
          34,
          35
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Implementar sistema de frases motivacionais com banco de dados e rotação automática",
        "description": "Criar módulo de conteúdo automático para exibição de frases motivacionais com banco de dados, categorização e rotação configurável por tempo ou evento nos players.",
        "details": "Implementar os seguintes componentes:\n\n**Migration e Model Quote:**\n- Criar migration `create_quotes_table` com campos: `id`, `tenant_id`, `text`, `author`, `category`, `is_active`, `display_duration`, `created_at`, `updated_at`\n- Criar model `app/Models/Quote.php` com relacionamento `belongsTo(Tenant::class)` e scope para quotes ativas\n- Implementar categorias: motivacional, inspiracional, empresarial, sucesso, liderança\n- Adicionar campos para configuração de duração de exibição (em segundos)\n\n**Service QuoteService:**\n- Criar `app/Services/QuoteService.php` com métodos `getRandomQuote($tenant, $category = null)` e `getRotationSequence($tenant, $options)`\n- Implementar lógica de rotação: sequencial, aleatória, por categoria, por tempo\n- Método `seedDefaultQuotes($tenant)` para popular banco com frases padrão\n- Configurar cache de 1 hora para otimizar consultas frequentes\n\n**Controller QuoteController:**\n- Criar `app/Http/Controllers/QuoteController.php` com CRUD completo para gestão de frases\n- Implementar endpoints: `index()`, `store()`, `update()`, `destroy()`, `toggle()` para ativar/desativar\n- Adicionar método `preview()` para visualizar frase antes de salvar\n- Validação: texto máximo 500 caracteres, autor máximo 100 caracteres\n\n**API para Players:**\n- Adicionar endpoint `GET /api/player/quotes/current` em PlayerController para retornar frase atual\n- Implementar endpoint `GET /api/player/quotes/next` para buscar próxima frase da rotação\n- Incluir configurações de timing e transição no response JSON\n- Integrar com sistema de autenticação de players existente\n\n**Frontend - Páginas Inertia:**\n- Criar `resources/js/pages/Quotes/Index.tsx` com listagem, filtros por categoria e status\n- Criar `resources/js/pages/Quotes/Create.tsx` e `Edit.tsx` com formulários de cadastro/edição\n- Implementar componente `QuotePreview.tsx` para visualização em tempo real\n- Adicionar configurações de rotação: intervalo (30s a 10min), modo (sequencial/aleatório), categorias ativas\n\n**Configurações e Seeding:**\n- Criar seeder `QuoteSeeder.php` com 50+ frases motivacionais em português\n- Adicionar configuração `config/quotes.php` para intervals padrão e categorias\n- Implementar comando artisan `quotes:seed` para popular banco com frases padrão",
        "testStrategy": "1. Criar teste de feature `php artisan make:test QuoteManagementTest` para testar CRUD completo de frases\n2. Testar rotação automática: criar 10 frases, configurar rotação sequencial e aleatória, verificar se não há repetições imediatas\n3. Testar filtros por categoria: criar frases em diferentes categorias, buscar por categoria específica e verificar resultados\n4. Testar API para players: simular requests de player autenticado e verificar response com frase atual e configurações\n5. Testar validações: tentar criar frases com texto muito longo, categoria inválida e verificar mensagens de erro\n6. Testar cache: fazer múltiplas consultas de frases e verificar se cache está funcionando corretamente\n7. Testar seeder: executar comando de seed e verificar se frases padrão são criadas corretamente\n8. Testar frontend: navegar pelas páginas de gestão, criar/editar frases e verificar preview em tempo real",
        "status": "done",
        "dependencies": [
          2,
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Implementar integração com API de cotações de moedas para conteúdos automáticos",
        "description": "Criar sistema de integração com APIs de cotações financeiras (USD, EUR, BTC) para exibição automática de dados de câmbio em tempo real nos players, incluindo job de sincronização e componente de visualização.",
        "details": "Implementar os seguintes componentes:\n\n**Service CurrencyService:**\n- Criar `app/Services/CurrencyService.php` com métodos para buscar cotações de diferentes APIs\n- Implementar adaptadores para múltiplas fontes: CoinGecko (gratuito), ExchangeRate-API, ou Fixer.io\n- Configurar timeout de 10 segundos e retry automático em caso de falha\n- Método `getCurrencyRates(['USD', 'EUR', 'BTC'])` retornando array padronizado\n- Cache de 5 minutos para evitar excesso de requests\n\n**Model CurrencyRate:**\n- Criar migration `create_currency_rates_table` com campos: `currency`, `rate_brl`, `updated_at`, `source`\n- Modelo `app/Models/CurrencyRate.php` com scope para moedas ativas\n- Relacionamento com tenant para permitir configurações personalizadas\n\n**Job UpdateCurrencyRates:**\n- Criar `app/Jobs/UpdateCurrencyRates.php` executado a cada 5 minutos via scheduler\n- Buscar cotações via CurrencyService e atualizar tabela `currency_rates`\n- Log de erros e métricas de sucesso/falha\n\n**API Endpoint:**\n- Criar endpoint `/api/player/currency-rates` para players consumirem dados atualizados\n- Retornar JSON com cotações e timestamp da última atualização\n\n**Configuração:**\n- Adicionar variáveis de ambiente para API keys das fontes de cotação\n- Configurar scheduler no `app/Console/Kernel.php` para job automático\n- Implementar fallback entre diferentes APIs em caso de indisponibilidade",
        "testStrategy": "1. Criar teste de unit `php artisan make:test CurrencyServiceTest` para testar integração com APIs de cotação\n2. Testar diferentes fontes de dados: configurar múltiplas APIs e verificar se fallback funciona corretamente\n3. Testar cache: fazer múltiplas chamadas em sequência e verificar se segunda chamada usa cache\n4. Criar teste de feature `php artisan make:test UpdateCurrencyRatesJobTest` para job de atualização\n5. Testar scheduler: executar job e verificar se cotações são atualizadas no banco\n6. Testar endpoint API: fazer request para `/api/player/currency-rates` e verificar formato de resposta\n7. Testar cenários de erro: simular APIs offline e verificar se sistema continua funcionando com dados em cache\n8. Testar performance: verificar se updates não impactam performance geral do sistema",
        "status": "done",
        "dependencies": [
          2,
          30
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Criar sistema de geração de tokens únicos para ativação de players com QR code e link curto",
        "description": "Implementar sistema completo de geração de tokens únicos para ativação de players Android, incluindo códigos de ativação, QR codes, links curtos e interface de gerenciamento no painel administrativo.",
        "details": "Implementar os seguintes componentes:\n\n**Migration e Model PlayerActivationToken:**\n- Criar migration `create_player_activation_tokens_table` com campos: `id`, `tenant_id`, `token`, `activation_code`, `qr_code_path`, `short_url`, `player_id`, `expires_at`, `is_used`, `used_at`, `created_at`, `updated_at`\n- Criar model `app/Models/PlayerActivationToken.php` com relacionamentos `belongsTo(Tenant::class)` e `belongsTo(Player::class)`\n- Implementar scopes para tokens ativos, expirados e não utilizados\n- Adicionar mutators para gerar token único de 32 caracteres e código de ativação de 8 dígitos\n\n**Service TokenGenerationService:**\n- Criar `app/Services/TokenGenerationService.php` com método `generateActivationToken($tenant, $playerData = [])`\n- Implementar geração de token único usando `Str::random(32)` com verificação de duplicatas\n- Gerar código de ativação numérico de 8 dígitos fácil de digitar\n- Configurar expiração padrão de 24 horas (configurável por tenant)\n- Método `generateQRCode($token)` usando biblioteca SimpleSoftwareIO/simple-qrcode\n- Método `generateShortUrl($token)` criando URL encurtada no formato `/a/{token}`\n\n**Controller ActivationController:**\n- Criar `app/Http/Controllers/ActivationController.php` com métodos para gerenciar tokens\n- Método `index()`: listar tokens ativos do tenant com filtros por status\n- Método `store()`: gerar novo token com QR code e link curto\n- Método `show($token)`: exibir página de ativação pública com QR code\n- Método `download($token)`: fazer download do QR code como PNG\n- Método `revoke($token)`: revogar token não utilizado\n\n**Interface de Ativação:**\n- Criar view `activation.show` com QR code, código de ativação e instruções\n- Implementar página responsiva para exibição em dispositivos móveis\n- Adicionar botão para download do QR code e compartilhamento do link\n- Criar componente React para geração de tokens no painel administrativo",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlayerActivationTest` para verificar fluxo completo de geração e ativação de tokens\n2. Testar geração de tokens: verificar unicidade de tokens, códigos de ativação e URLs encurtadas\n3. Testar QR codes: gerar token, verificar se arquivo de QR code é criado e contém URL correta\n4. Testar expiração: criar token com expiração de 1 minuto, aguardar e verificar se token é considerado expirado\n5. Testar ativação: simular processo de ativação via API com código válido/inválido e verificar atualização de status\n6. Testar links curtos: acessar URL `/a/{token}` e verificar se redireciona para página de ativação correta\n7. Testar revogação: revogar token não utilizado e verificar se não pode mais ser usado para ativação\n8. Testar interface: verificar se QR code é exibido corretamente e se download funciona em diferentes dispositivos",
        "status": "done",
        "dependencies": [
          9,
          21
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Implementar geração de QR codes para ativação de players usando biblioteca PHP com customização de logo e cores",
        "description": "Criar sistema de geração de QR codes customizáveis para ativação de players Android, incluindo integração com biblioteca PHP, personalização visual por tenant e endpoint para download de códigos únicos.",
        "details": "Implementar os seguintes componentes:\n\n**Service QRCodeService:**\n- Criar `app/Services/QRCodeService.php` com método `generatePlayerActivationQR($player, $options = [])`\n- Integrar biblioteca `simplesoftwareio/simple-qrcode` ou `endroid/qr-code` via Composer\n- Implementar personalização: logo do tenant, cores primária/secundária, tamanho e margem\n- Método `generateQRCode($data, $logo = null, $primaryColor = '#000000', $backgroundColor = '#FFFFFF')`\n- Salvar QR codes gerados em storage público: `storage/app/public/qr-codes/{tenant_id}/{player_id}.png`\n\n**Controller QRCodeController:**\n- Criar `app/Http/Controllers/QRCodeController.php` com métodos `generate()` e `download()`\n- Endpoint `GET /qr-code/player/{player}/generate` para gerar QR code de ativação\n- Endpoint `GET /qr-code/player/{player}/download` para download direto do arquivo PNG\n- Validar se usuário tem permissão para acessar player do tenant\n- Implementar cache de 1 hora para evitar regerar QR codes idênticos\n\n**Model Player - Extensão:**\n- Adicionar método `getActivationUrl()` que retorna URL completa para ativação: `{app_url}/api/player/activate?token={unique_token}`\n- Adicionar método `generateQRCode($options = [])` que chama QRCodeService\n- Implementar geração automática de QR code após criação do player\n\n**Frontend Integration:**\n- Criar componente React `QRCodeDisplay.tsx` para visualização e download\n- Adicionar botão \"Gerar QR Code\" na página de detalhes do player\n- Implementar modal com preview do QR code e opções de personalização\n- Permitir download direto do arquivo PNG gerado",
        "testStrategy": "1. Criar teste de unit `php artisan make:test QRCodeServiceTest` para testar geração de QR codes com diferentes configurações\n2. Testar personalização visual: gerar QR codes com logos diferentes, cores customizadas e verificar se arquivos são salvos corretamente\n3. Testar endpoints: fazer requests para `/qr-code/player/{id}/generate` e `/qr-code/player/{id}/download`, verificar responses e headers corretos\n4. Testar integração com Player: criar novo player, verificar se QR code é gerado automaticamente e se URL de ativação está correta\n5. Testar permissões: tentar acessar QR codes de players de outros tenants, verificar se acesso é negado\n6. Testar cache: gerar mesmo QR code múltiplas vezes e verificar se arquivo não é recriado desnecessariamente\n7. Testar componente React: verificar se modal de QR code abre corretamente e se download funciona no frontend",
        "status": "done",
        "dependencies": [
          34,
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Implementar sistema de agendamento de playlists com suporte a intervalos de datas, horários específicos e dias da semana",
        "description": "Criar sistema completo de agendamento de playlists permitindo configuração de intervalos de datas, horários específicos e dias da semana com job de verificação e aplicação automática dos agendamentos.",
        "details": "Implementar os seguintes componentes:\n\n**Model PlaylistSchedule:**\n- Criar `app/Models/PlaylistSchedule.php` com campos: `playlist_id`, `tenant_id`, `name`, `start_date`, `end_date`, `start_time`, `end_time`, `days_of_week` (JSON), `is_active`, `priority`\n- Relacionamentos: `belongsTo(Playlist::class)`, `belongsTo(Tenant::class)`\n- Scopes: `active()`, `currentlyActive()`, `byDayOfWeek($day)`\n- Validações: datas válidas, horários no formato HH:MM, dias da semana como array [0-6]\n\n**Service ScheduleService:**\n- Criar `app/Services/ScheduleService.php` com métodos para gerenciar agendamentos\n- Método `createSchedule($playlistId, $scheduleData)` para criar novos agendamentos\n- Método `getActiveSchedulesForDateTime($dateTime)` para buscar agendamentos ativos\n- Método `checkScheduleConflicts($scheduleData)` para verificar sobreposições\n- Lógica de prioridade: agendamentos com maior prioridade sobrescrevem menores\n\n**Controller PlaylistScheduleController:**\n- Criar `app/Http/Controllers/PlaylistScheduleController.php` com CRUD completo\n- Métodos: `index()`, `create()`, `store()`, `show()`, `edit()`, `update()`, `destroy()`\n- Validação de conflitos de horário antes de salvar\n- Aplicar TenantScope para isolamento de dados\n\n**Job ProcessScheduledPlaylists:**\n- Criar `app/Jobs/ProcessScheduledPlaylists.php` para executar a cada minuto\n- Verificar agendamentos ativos no momento atual considerando data, hora e dia da semana\n- Aplicar playlists agendadas aos players correspondentes\n- Registrar logs de ativação/desativação de agendamentos\n\n**Migration create_playlist_schedules_table:**\n- Criar tabela com campos: `id`, `playlist_id`, `tenant_id`, `name`, `start_date`, `end_date`, `start_time`, `end_time`, `days_of_week`, `is_active`, `priority`, `created_at`, `updated_at`\n- Índices em `tenant_id`, `playlist_id`, `is_active` para performance\n- Foreign keys com cascade delete\n\n**Frontend Components:**\n- Criar formulário React para configuração de agendamentos com calendário e seletor de horários\n- Interface para visualização de agendamentos em formato de timeline/calendário\n- Validação frontend para conflitos de horário e datas inválidas",
        "testStrategy": "1. Criar teste de unit `php artisan make:test ScheduleServiceTest` para testar lógica de agendamentos isoladamente\n2. Testar criação de agendamentos: criar agendamentos com diferentes configurações de data/hora e verificar se são salvos corretamente\n3. Testar detecção de conflitos: criar agendamentos sobrepostos e verificar se sistema detecta e impede conflitos\n4. Testar job ProcessScheduledPlaylists: simular diferentes cenários de tempo e verificar se playlists corretas são ativadas\n5. Testar prioridades: criar agendamentos com diferentes prioridades no mesmo horário e verificar se o de maior prioridade prevalece\n6. Testar dias da semana: configurar agendamentos para dias específicos e verificar se ativam apenas nos dias corretos\n7. Criar teste de feature `php artisan make:test PlaylistScheduleControllerTest` para testar CRUD completo via interface web\n8. Testar isolamento por tenant: verificar se agendamentos de um tenant não afetam outros tenants",
        "status": "done",
        "dependencies": [
          2,
          3,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Criar job RecurringPlaylistScheduler para processar agendamentos recorrentes e ativar/desativar playlists automaticamente",
        "description": "Implementar job de background para processar agendamentos recorrentes de playlists, verificando horários e dias da semana configurados para ativar/desativar playlists automaticamente nos players.",
        "details": "Implementar os seguintes componentes:\n\n**Job RecurringPlaylistScheduler:**\n- Criar `app/Jobs/RecurringPlaylistScheduler.php` usando `php artisan make:job RecurringPlaylistScheduler`\n- Implementar método `handle()` que executa a cada minuto via cron job\n- Buscar todos os agendamentos ativos (`PlaylistSchedule::active()`) do banco\n- Verificar se horário atual coincide com `start_time`/`end_time` e dia da semana está em `days_of_week`\n- Ativar playlists nos players quando agendamento inicia usando `PlayerPlaylistService`\n- Desativar playlists quando agendamento termina, respeitando prioridades\n\n**Configuração de Cron:**\n- Adicionar comando `schedule:run` no `app/Console/Kernel.php`\n- Configurar job para executar `->everyMinute()` no método `schedule()`\n- Implementar logging de ativações/desativações para auditoria\n\n**Lógica de Prioridades:**\n- Quando múltiplos agendamentos conflitam, usar campo `priority` (maior número = maior prioridade)\n- Manter histórico de mudanças em log estruturado\n- Implementar fallback para playlist padrão quando nenhum agendamento está ativo\n\n**Service Integration:**\n- Usar `ScheduleService` existente para verificar agendamentos ativos\n- Integrar com `PlayerPlaylistService` para aplicar mudanças nos players\n- Adicionar notificações em caso de falhas de ativação",
        "testStrategy": "1. Criar teste de unit `php artisan make:test RecurringPlaylistSchedulerTest` para testar lógica de processamento isoladamente\n2. Testar ativação automática: criar agendamento que deve iniciar no horário atual, executar job manualmente e verificar se playlist foi ativada no player\n3. Testar desativação automática: criar agendamento que deve terminar, executar job e verificar se playlist foi desativada\n4. Testar conflitos de prioridade: criar 2 agendamentos sobrepostos com prioridades diferentes, verificar se playlist de maior prioridade prevalece\n5. Testar dias da semana: criar agendamento para dias específicos, executar em dias incluídos e excluídos, verificar comportamento correto\n6. Testar job scheduling: configurar cron job e verificar se executa automaticamente a cada minuto\n7. Testar fallback: remover todos os agendamentos ativos e verificar se playlist padrão é aplicada\n8. Criar teste de integração verificando logs de ativação/desativação para auditoria",
        "status": "done",
        "dependencies": [
          50,
          23,
          11
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Implementar sistema de logs para ações administrativas e de usuários",
        "description": "Criar sistema completo de auditoria e logs para rastrear todas as ações administrativas como criação/edição de players, upload de mídias, mudanças de configuração e ações de usuários no sistema.",
        "details": "Implementar os seguintes componentes:\n\n**Model ActivityLog:**\n- Criar `app/Models/ActivityLog.php` com campos: `user_id`, `tenant_id`, `action`, `model_type`, `model_id`, `old_values`, `new_values`, `ip_address`, `user_agent`, `created_at`\n- Definir relacionamentos: `belongsTo(User::class)`, `belongsTo(Tenant::class)`, `morphTo()` para model auditado\n- Implementar scopes: `forTenant()`, `forUser()`, `forModel()`, `byAction()`\n- Configurar casting para `old_values` e `new_values` como JSON\n\n**Service ActivityLogService:**\n- Criar `app/Services/ActivityLogService.php` com método `log($action, $model, $oldValues = null, $newValues = null)`\n- Capturar automaticamente: IP address, user agent, usuário autenticado, tenant atual\n- Implementar métodos específicos: `logPlayerCreated()`, `logMediaUploaded()`, `logConfigChanged()`, `logPlaylistModified()`\n- Sanitizar dados sensíveis antes de salvar (senhas, tokens)\n\n**Middleware LogActivity:**\n- Criar `app/Http/Middleware/LogActivity.php` para capturar automaticamente ações via requests\n- Registrar middleware em `Kernel.php` no grupo 'web' e 'api'\n- Implementar detecção de ações baseada em rotas e métodos HTTP\n\n**Observer Pattern para Models:**\n- Criar observers para models principais: `PlayerObserver`, `MediaFileObserver`, `PlaylistObserver`\n- Implementar métodos `created()`, `updated()`, `deleted()` chamando ActivityLogService\n- Registrar observers no `AppServiceProvider`\n\n**Controller ActivityLogController:**\n- Criar `app/Http/Controllers/ActivityLogController.php` com método `index()` para listagem paginada\n- Implementar filtros: por usuário, por ação, por modelo, por período\n- Método `show($id)` para detalhes específicos de um log\n- Endpoint API `/api/activity-logs` para consumo externo\n\n**Interface de Visualização:**\n- Criar página React `resources/js/pages/ActivityLogs/Index.tsx` com tabela de logs\n- Implementar filtros avançados: data range picker, select de usuários, select de ações\n- Exibir detalhes em modal: valores antigos vs novos, diff visual para mudanças\n- Paginação server-side com ordenação por data descendente",
        "testStrategy": "1. Criar teste de unit `php artisan make:test ActivityLogServiceTest` para testar métodos de logging isoladamente\n2. Testar logging automático: criar player, editar configuração, fazer upload - verificar se logs são gerados corretamente\n3. Testar observers: usar factories para criar/editar models e verificar se ActivityLog records são criados automaticamente\n4. Testar filtros: criar logs com diferentes usuários/ações/datas e verificar se filtros funcionam corretamente na interface\n5. Testar sanitização: tentar logar dados sensíveis e verificar se são removidos antes de salvar\n6. Testar performance: criar 1000+ logs e verificar se consultas são otimizadas com índices apropriados\n7. Testar API endpoints: fazer requests para `/api/activity-logs` com diferentes filtros e verificar resposta JSON\n8. Testar interface React: verificar se tabela carrega, filtros funcionam e modal de detalhes exibe diff corretamente",
        "status": "done",
        "dependencies": [
          2,
          30,
          43
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Criar sistema de logs de player para rastrear reprodução de mídias, erros de conectividade e performance",
        "description": "Implementar sistema completo de logging para players Android que registra eventos de reprodução de mídia, erros de conectividade, métricas de performance e sincronização automática com o painel administrativo.",
        "details": "Implementar os seguintes componentes:\n\n**Migration e Model PlayerLog:**\n- Criar migration `create_player_logs_table` com campos: `id`, `player_id`, `tenant_id`, `event_type`, `event_data` (JSON), `media_file_id`, `timestamp`, `ip_address`, `user_agent`, `created_at`, `updated_at`\n- Criar model `app/Models/PlayerLog.php` com relacionamentos `belongsTo(Player::class)`, `belongsTo(Tenant::class)`, `belongsTo(MediaFile::class)`\n- Implementar enum para tipos de evento: `MEDIA_START`, `MEDIA_END`, `MEDIA_ERROR`, `CONNECTION_ERROR`, `PERFORMANCE_METRIC`, `HEARTBEAT`\n- Configurar casts para `event_data` como array JSON e `timestamp` como Carbon\n\n**Service PlayerLogService:**\n- Criar `app/Services/PlayerLogService.php` com métodos para diferentes tipos de log\n- Método `logMediaEvent($playerId, $eventType, $mediaFileId, $eventData = [])` para eventos de reprodução\n- Método `logConnectivityError($playerId, $errorType, $errorDetails)` para erros de conexão\n- Método `logPerformanceMetric($playerId, $metrics)` para dados de CPU, memória, temperatura\n- Implementar rate limiting para evitar spam de logs\n- Configurar limpeza automática de logs antigos (> 90 dias)\n\n**Controller PlayerLogController:**\n- Criar `app/Http/Controllers/PlayerLogController.php` para visualização no painel\n- Método `index()` com filtros por player, tipo de evento, data e paginação\n- Método `show($logId)` para detalhes específicos de um log\n- Implementar exportação CSV/JSON para análises\n- Dashboard com gráficos de performance e estatísticas de uso\n\n**API Endpoints para Players:**\n- Adicionar ao `PlayerApiController` endpoint `POST /api/player/log` para receber logs dos dispositivos\n- Implementar batch logging para envio de múltiplos logs de uma vez\n- Configurar compressão gzip para reduzir tráfego de dados\n- Validação de estrutura de dados e sanitização de entrada\n\n**Job de Análise de Logs:**\n- Criar `app/Jobs/AnalyzePlayerLogsJob.php` para processamento assíncrono\n- Detectar padrões de erro e alertas automáticos\n- Gerar relatórios de performance por player/tenant\n- Integrar com sistema de notificações para alertas críticos",
        "testStrategy": "1. Criar teste de feature `php artisan make:test PlayerLogTest` para verificar criação e recuperação de logs com diferentes tipos de evento\n2. Testar API de logging: enviar logs de diferentes tipos via endpoint `/api/player/log` e verificar se são salvos corretamente no banco\n3. Testar filtros e busca: criar logs com diferentes players, datas e tipos, depois testar filtros no painel administrativo\n4. Testar rate limiting: enviar múltiplos logs rapidamente e verificar se limitação está funcionando\n5. Testar limpeza automática: criar logs antigos e executar job de limpeza para verificar remoção\n6. Testar batch logging: enviar array de logs em uma única requisição e verificar processamento correto\n7. Testar análise de logs: criar logs com padrões de erro e verificar se job de análise detecta problemas\n8. Testar exportação: gerar logs e exportar em diferentes formatos (CSV, JSON) verificando integridade dos dados\n9. Testar dashboard: verificar se gráficos e estatísticas são gerados corretamente baseados nos logs\n10. Testar isolamento por tenant: verificar se logs são filtrados corretamente por tenant usando TenantScope",
        "status": "in-progress",
        "dependencies": [
          9,
          21,
          30,
          33
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "Implementar sistema de alertas por email para notificações de player offline, erro de reprodução e limite de storage",
        "description": "Criar sistema completo de notificações por email para alertar administradores sobre eventos críticos: players offline, erros de reprodução de mídia e limites de armazenamento próximos do máximo.",
        "details": "Implementar os seguintes componentes:\n\n**Model AlertRule:**\n- Criar `app/Models/AlertRule.php` com campos: `tenant_id`, `type`, `condition`, `threshold`, `recipients`, `is_active`, `last_triggered_at`\n- Tipos: 'player_offline', 'playback_error', 'storage_limit'\n- Relacionamentos: `belongsTo(Tenant::class)`, casting `recipients` como array\n- Scopes: `active()`, `byType($type)`, `forTenant()`\n\n**Service AlertService:**\n- Criar `app/Services/AlertService.php` com métodos para verificar condições e disparar alertas\n- `checkPlayerStatus()`: verificar players offline há mais de X minutos\n- `checkStorageUsage()`: calcular percentual de uso vs limite do plano\n- `checkPlaybackErrors()`: monitorar logs de erro de reprodução\n- `sendAlert($rule, $data)`: enviar email usando queue\n\n**Job CheckAlerts:**\n- Criar `app/Jobs/CheckAlerts.php` para execução a cada 5 minutos via cron\n- Implementar verificação de todas as regras ativas por tenant\n- Evitar spam: verificar `last_triggered_at` para cooldown de 30 minutos\n- Disparar emails apenas quando condições são atendidas\n\n**Mailable Classes:**\n- `PlayerOfflineAlert`: template para notificar player offline\n- `PlaybackErrorAlert`: template para erros de reprodução\n- `StorageLimitAlert`: template para limite de storage próximo\n\n**Controller AlertController:**\n- CRUD para gerenciar regras de alerta no painel admin\n- Métodos: `index()`, `store()`, `update()`, `destroy()`, `toggle()`\n- Validação de recipients como emails válidos\n\n**Frontend Components:**\n- Página de configuração de alertas em `resources/js/pages/Settings/Alerts.tsx`\n- Formulário para criar/editar regras com campos dinâmicos por tipo\n- Toggle para ativar/desativar regras rapidamente",
        "testStrategy": "1. Criar teste de unit `php artisan make:test AlertServiceTest` para testar lógica de verificação de condições isoladamente\n2. Testar detecção de player offline: simular player com last_ping_at antigo, executar job e verificar se alerta é disparado\n3. Testar verificação de storage: criar tenant próximo do limite, verificar se cálculo de percentual está correto\n4. Testar cooldown de alertas: disparar mesmo alerta duas vezes seguidas, verificar se segundo não é enviado\n5. Testar templates de email: usar Mail::fake() e verificar se emails contêm informações corretas\n6. Criar teste de feature `php artisan make:test AlertManagementTest` para CRUD de regras via interface\n7. Testar job CheckAlerts: criar cenários com múltiplas regras ativas e verificar execução correta",
        "status": "pending",
        "dependencies": [
          52,
          43,
          2,
          30
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Criar sistema de configurações globais por tenant",
        "description": "Implementar sistema completo de configurações globais por tenant incluindo temas visuais, configurações padrão de players, preferências de notificação e interface de gerenciamento no painel administrativo.",
        "details": "Implementar os seguintes componentes:\n\n**Model TenantSettings:**\n- Criar `app/Models/TenantSettings.php` com campos: `tenant_id`, `category`, `key`, `value`, `type`, `is_encrypted`, `created_at`, `updated_at`\n- Relacionamentos: `belongsTo(Tenant::class)`\n- Implementar casting automático baseado no campo `type` (string, integer, boolean, json, array)\n- Scopes: `byCategory($category)`, `byKey($key)`, `forTenant($tenantId)`\n- Métodos helper: `getValue($key, $default = null)`, `setValue($key, $value, $type = 'string')`\n\n**Service TenantSettingsService:**\n- Criar `app/Services/TenantSettingsService.php` com métodos para CRUD de configurações\n- Implementar cache Redis com invalidação automática por tenant\n- Métodos: `get($tenant, $key, $default)`, `set($tenant, $key, $value, $type)`, `getByCategory($tenant, $category)`\n- Configurações pré-definidas: tema visual (light/dark/auto), configurações de player (volume padrão, timeout), notificações (email, sistema)\n\n**Controller TenantSettingsController:**\n- Criar controller com métodos: `index()`, `show($category)`, `update(Request $request)`\n- Validação de configurações usando FormRequest específicos por categoria\n- Interface para edição de configurações agrupadas por categoria\n\n**Frontend de Configurações:**\n- Criar páginas React em `resources/js/pages/Settings/` para cada categoria\n- Componentes: `ThemeSettings`, `PlayerDefaults`, `NotificationPreferences`\n- Formulários com validação em tempo real e preview de mudanças\n- Suporte a reset para valores padrão\n\n**Sistema de Migração de Configurações:**\n- Seeder para configurações padrão: `DefaultTenantSettingsSeeder`\n- Command artisan para migrar configurações: `tenant:migrate-settings`\n- Versionamento de configurações para atualizações futuras",
        "testStrategy": "1. Criar teste de unit `php artisan make:test TenantSettingsServiceTest` para testar operações CRUD de configurações isoladamente\n2. Testar cache: definir configuração, verificar cache, invalidar cache e verificar se dados são recarregados do banco\n3. Testar diferentes tipos de dados: string, integer, boolean, JSON - verificar se casting funciona corretamente\n4. Testar herança de configurações: tenant sem configuração específica deve usar valor padrão do sistema\n5. Criar teste de feature `php artisan make:test TenantSettingsControllerTest` para verificar interface de edição\n6. Testar validação de formulários: enviar dados inválidos e verificar se erros são retornados corretamente\n7. Testar aplicação de configurações: alterar tema e verificar se mudança é refletida na interface\n8. Testar configurações de player: verificar se configurações padrão são aplicadas em novos players criados\n9. Testar notificações: alterar preferências e verificar se alertas respeitam as configurações definidas",
        "status": "pending",
        "dependencies": [
          2,
          54
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 56,
        "title": "Implementar configurações individuais por player: volume, tempo entre mídias, looping, senha de acesso, tema visual personalizado",
        "description": "Criar sistema completo de configurações individuais por player permitindo personalização de volume, intervalos entre mídias, looping, autenticação por senha e temas visuais customizados por dispositivo.",
        "details": "Implementar os seguintes componentes:\n\n**Model PlayerSettings:**\n- Criar `app/Models/PlayerSettings.php` com campos: `player_id`, `setting_key`, `setting_value`, `setting_type`, `is_inherited`, `created_at`, `updated_at`\n- Relacionamentos: `belongsTo(Player::class)`\n- Implementar casting automático baseado no campo `setting_type` (integer, boolean, string, json)\n- Scopes: `forPlayer($playerId)`, `bySetting($key)`, `customOnly()` (não herdadas)\n- Métodos helper: `getValue($key, $default = null)`, `setValue($key, $value, $type = 'string')`\n\n**Service PlayerConfigService:**\n- Criar `app/Services/PlayerConfigService.php` para gerenciar configurações hierárquicas\n- Implementar herança: configurações do tenant como padrão, override por player quando definido\n- Método `getEffectiveConfig($player)` que mescla configurações globais com individuais\n- Configurações suportadas: `volume` (0-100), `media_interval` (segundos), `loop_enabled` (boolean), `access_password` (string), `visual_theme` (json)\n- Cache Redis com TTL de 5 minutos para configurações por player\n\n**Controller PlayerConfigController:**\n- Criar `app/Http/Controllers/PlayerConfigController.php` com rotas: `index`, `show`, `update`, `reset`\n- Implementar validação específica: volume (0-100), intervalo (1-3600s), senha (min 4 caracteres)\n- Endpoint `/players/{player}/config` para CRUD de configurações\n- Método `resetToDefault($player, $settingKey)` para voltar ao padrão do tenant\n\n**Interface Web de Configuração:**\n- Criar página `resources/js/pages/Players/Config.tsx` com formulário organizado por seções\n- Seção Áudio: slider para volume com preview visual\n- Seção Reprodução: campo numérico para intervalo, toggle para looping\n- Seção Segurança: campo password com gerador automático opcional\n- Seção Visual: seletor de tema com preview das cores primária/secundária\n- Indicadores visuais para configurações herdadas vs customizadas\n\n**API para Sincronização:**\n- Estender endpoint `/api/player/sync` para incluir configurações individuais\n- Retornar configurações efetivas (globais + individuais) no payload de sincronização\n- Implementar versionamento para detectar mudanças apenas quando necessário",
        "testStrategy": "1. Criar teste de unit `php artisan make:test PlayerConfigServiceTest` para testar lógica de herança e mesclagem de configurações\n2. Testar herança: definir configuração global, verificar se player herda, sobrescrever no player e verificar precedência\n3. Testar validação: enviar valores inválidos (volume > 100, intervalo negativo) e verificar se erros são retornados\n4. Testar interface web: acessar página de configuração, modificar diferentes settings e verificar se são persistidos corretamente\n5. Testar API de sincronização: fazer request de sync e verificar se configurações individuais são incluídas no payload\n6. Testar cache: modificar configuração, verificar cache, limpar cache e verificar se dados são recarregados do banco\n7. Criar teste de feature `php artisan make:test PlayerIndividualConfigTest` para testar fluxo completo de configuração via interface web",
        "status": "pending",
        "dependencies": [
          55,
          34,
          35,
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 57,
        "title": "Implementar validações robustas para upload de mídia com verificação de tipos, tamanho e vírus",
        "description": "Criar sistema completo de validações para upload de arquivos de mídia incluindo verificação de tipos MIME permitidos, limites de tamanho por tenant, análise de segurança e preparação para futura integração antivírus.",
        "details": "Implementar os seguintes componentes:\n\n**Service MediaValidationService:**\n- Criar `app/Services/MediaValidationService.php` com método `validateUpload($file, $tenant, $options = [])`\n- Implementar validação de MIME types: vídeos (mp4, mov, avi, mkv), imagens (jpg, jpeg, png, gif, webp), áudio (mp3, wav, aac)\n- Verificar extensão vs MIME type para detectar possíveis arquivos maliciosos\n- Validar tamanho máximo baseado no plano do tenant (básico: 100MB, premium: 500MB, enterprise: 2GB)\n- Implementar verificação de cabeçalho de arquivo para detectar tipos não permitidos\n- Método `scanFileContent($filePath)` para análise básica de conteúdo suspeito\n\n**Middleware UploadValidationMiddleware:**\n- Criar `app/Http/Middleware/UploadValidationMiddleware.php` para aplicar validações automaticamente\n- Integrar com rotas de upload existentes\n- Retornar erros específicos: 'invalid_mime_type', 'file_too_large', 'suspicious_content'\n\n**Model FileValidationLog:**\n- Criar modelo para logging de tentativas de upload suspeitas\n- Campos: `tenant_id`, `user_id`, `original_filename`, `mime_type`, `file_size`, `validation_status`, `rejection_reason`\n\n**Preparação para Antivírus:**\n- Estruturar interface `AntivirusScanner` para futura integração com ClamAV/VirusTotal\n- Criar configuração em `config/media.php` para habilitar/desabilitar verificação antivírus\n- Implementar job `ScanFileForVirus` para processamento assíncrono",
        "testStrategy": "1. Criar teste de unit `php artisan make:test MediaValidationServiceTest` para testar cada tipo de validação isoladamente\n2. Testar tipos MIME permitidos: enviar arquivos de vídeo, imagem e áudio válidos - verificar aprovação\n3. Testar tipos não permitidos: enviar executáveis, documentos, archives - verificar rejeição com motivo específico\n4. Testar limites de tamanho: criar tenants com diferentes planos e enviar arquivos de tamanhos variados\n5. Testar detecção de spoofing: renomear arquivo .exe para .mp4 e verificar se é detectado\n6. Testar middleware: fazer requests de upload e verificar se validações são aplicadas automaticamente\n7. Testar logging: enviar arquivos suspeitos e verificar se tentativas são registradas no FileValidationLog\n8. Testar performance: medir tempo de validação para arquivos grandes (>100MB)\n9. Testar integração: verificar se validações funcionam com sistema de upload S3/MinIO existente",
        "status": "done",
        "dependencies": [
          30
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 58,
        "title": "Implementar validações para agendamento de playlists com verificação de conflitos de horário e prioridades",
        "description": "Criar sistema completo de validações para agendamento de playlists incluindo detecção de conflitos de horário, validação de datas futuras, verificação de prioridades e prevenção de sobreposições em players específicos.",
        "details": "Implementar os seguintes componentes:\n\n**Service PlaylistScheduleValidationService:**\n- Criar `app/Services/PlaylistScheduleValidationService.php` com método `validateSchedule($playlistId, $startDateTime, $endDateTime, $playerId, $priority)`\n- Implementar detecção de conflitos: buscar agendamentos existentes no mesmo player com sobreposição de horário\n- Validar prioridades: permitir agendamento com prioridade maior que substitua agendamentos de prioridade menor\n- Verificar datas futuras: start_at deve ser maior que now(), end_at deve ser maior que start_at\n- Implementar regras de negócio: duração mínima 5 minutos, máxima 24 horas, intervalo mínimo 1 minuto entre agendamentos\n\n**Model PlaylistSchedule:**\n- Criar `app/Models/PlaylistSchedule.php` com campos: `playlist_id`, `player_id`, `start_at`, `end_at`, `priority`, `status`, `created_by`\n- Relacionamentos: `belongsTo(Playlist::class)`, `belongsTo(Player::class)`, `belongsTo(User::class, 'created_by')`\n- Scopes: `active()`, `forPlayer($playerId)`, `conflictsWith($startAt, $endAt)`, `byPriority()`\n- Métodos: `hasConflict($startAt, $endAt, $playerId)`, `canOverride($priority)`\n\n**Middleware ScheduleValidationMiddleware:**\n- Criar middleware para validar automaticamente requests de agendamento\n- Aplicar em rotas de criação e edição de agendamentos\n- Retornar erros 422 com detalhes específicos dos conflitos encontrados\n\n**Rules de Validação Custom:**\n- `app/Rules/NoScheduleConflict.php`: verificar conflitos de horário\n- `app/Rules/ValidSchedulePriority.php`: validar níveis de prioridade (1-10)\n- `app/Rules/FutureDateTime.php`: garantir que agendamentos são para o futuro\n- `app/Rules/ValidScheduleDuration.php`: validar duração mínima e máxima",
        "testStrategy": "1. Criar teste de unit `php artisan make:test PlaylistScheduleValidationServiceTest` para testar cada regra de validação isoladamente\n2. Testar conflitos de horário: criar agendamento de 10h-12h, tentar criar 11h-13h no mesmo player - deve detectar conflito\n3. Testar prioridades: agendar prioridade 5 de 10h-12h, tentar prioridade 7 de 11h-13h - deve permitir e cancelar o anterior\n4. Testar validação de datas: tentar agendar no passado, end_at antes de start_at, duração muito curta/longa\n5. Criar teste de feature `php artisan make:test ScheduleConflictTest` para cenários complexos com múltiplos players e agendamentos\n6. Testar middleware: enviar requests inválidos via HTTP e verificar responses 422 com mensagens específicas\n7. Testar rules customizadas: usar em factory/seeder para gerar dados válidos e inválidos\n8. Testar cenários edge: agendamentos que se tocam (sem sobreposição), mudança de timezone, agendamentos recorrentes",
        "status": "done",
        "dependencies": [
          11,
          12,
          23
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 59,
        "title": "Implementar cache Redis para configurações de players, playlists ativas e dados de sincronização frequente",
        "description": "Criar sistema de cache Redis para otimizar performance na sincronização de dados entre players e servidor, armazenando configurações, playlists ativas e informações acessadas frequentemente.",
        "details": "Implementar os seguintes componentes:\n\n**Configuração Redis:**\n- Configurar Redis no `config/cache.php` e `config/database.php` para conexão dedicada\n- Adicionar variáveis de ambiente: `REDIS_CACHE_HOST`, `REDIS_CACHE_PORT`, `REDIS_CACHE_PASSWORD`, `REDIS_CACHE_DB`\n- Configurar TTL padrão de 1 hora para dados de configuração e 15 minutos para playlists ativas\n\n**Service PlayerCacheService:**\n- Criar `app/Services/PlayerCacheService.php` com métodos `cachePlayerConfig($player)`, `getCachedPlayerConfig($playerId)`, `invalidatePlayerCache($playerId)`\n- Implementar cache de configurações: resolução, orientação, volume, intervalo_sync\n- Cache de playlists ativas por player: `cache:playlist:active:{player_id}` contendo dados completos da playlist e mídias\n- Método `cachePlaylistData($playlistId, $data, $ttl = 900)` para armazenar dados de sincronização\n\n**Service SyncCacheService:**\n- Criar `app/Services/SyncCacheService.php` com métodos para cache de dados de sincronização\n- Cache de timestamps de última sincronização: `cache:sync:timestamp:{player_id}`\n- Cache de checksums de arquivos para detecção de mudanças: `cache:file:checksum:{file_id}`\n- Método `getSyncDataFromCache($playerId, $lastSync)` retornando apenas dados modificados\n- Invalidação inteligente baseada em eventos: player atualizado, playlist modificada, mídia alterada\n\n**Integração com Controllers Existentes:**\n- Modificar `PlayerSyncController::sync()` para usar cache antes de consultar banco\n- Implementar fallback para banco quando cache não disponível\n- Adicionar middleware `CacheResponse` para endpoints de sincronização frequente\n- Cache de resultados de API de cotações e clima por 5-15 minutos\n\n**Cache Tags e Invalidação:**\n- Implementar sistema de tags: `player:{id}`, `playlist:{id}`, `tenant:{id}`, `sync_data`\n- Observers em models para invalidação automática: PlayerObserver, PlaylistObserver, MediaFileObserver\n- Comando artisan `cache:warm-players` para pré-aquecer cache de todos os players ativos\n- Método `flushPlayerCaches($tenantId = null)` para limpeza completa\n\n**Monitoramento e Métricas:**\n- Implementar logs de cache hit/miss rates\n- Métricas de performance: tempo de resposta com/sem cache\n- Dashboard simples para visualizar estatísticas de cache por tenant",
        "testStrategy": "1. Criar teste de unit `php artisan make:test PlayerCacheServiceTest` para testar operações de cache isoladamente\n2. Testar cache de configurações: salvar configuração de player, recuperar do cache e verificar se dados estão corretos\n3. Testar invalidação automática: modificar playlist ativa, verificar se cache é limpo e dados atualizados\n4. Testar fallback para banco: desabilitar Redis temporariamente e verificar se sincronização ainda funciona\n5. Criar teste de performance `SyncPerformanceTest`: comparar tempo de resposta de `/api/player/sync` com e sem cache habilitado\n6. Testar cache tags: invalidar cache por tenant e verificar se apenas caches relacionados são limpos\n7. Testar TTL: configurar TTL baixo (1 minuto), aguardar expiração e verificar se dados são buscados novamente do banco\n8. Criar teste de integração `PlayerSyncCacheIntegrationTest`: simular múltiplos players sincronizando simultaneamente e verificar consistência dos dados\n9. Testar comando warm-up: executar `php artisan cache:warm-players` e verificar se cache é populado corretamente\n10. Testar cenários de alta concorrência: múltiplas requests simultâneas para mesmo player e verificar race conditions",
        "status": "done",
        "dependencies": [
          35,
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 60,
        "title": "Otimizar queries de sincronização de players com eager loading e índices apropriados",
        "description": "Implementar otimizações de performance para queries de sincronização de players utilizando eager loading para relacionamentos e criando índices estratégicos no banco de dados para reduzir tempo de resposta.",
        "details": "Implementar os seguintes componentes:\n\n**Otimização de Queries com Eager Loading:**\n- Modificar `PlayerApiController::sync()` para usar `Player::with(['tenant', 'playlists.medias', 'logs' => function($query) { $query->latest()->limit(10); }])`\n- Implementar eager loading seletivo baseado no endpoint: `/sync` carrega playlists ativas, `/status` carrega apenas configurações básicas\n- Criar scope `withSyncData()` no model Player para centralizar eager loading de sincronização\n- Otimizar query de playlists ativas: `$player->playlists()->with('medias')->where('is_active', true)->get()`\n\n**Índices Estratégicos:**\n- Criar migration `add_performance_indexes_to_players_table` com índices:\n  - `index(['tenant_id', 'status', 'last_seen_at'])` para queries de players ativos por tenant\n  - `index(['activation_code'])` para ativação rápida\n  - `index(['api_token'])` para autenticação API\n  - `index(['last_seen_at'])` para verificação de status online\n- Adicionar índices em `player_playlists`: `index(['player_id', 'created_at'])` para sincronização ordenada\n- Criar índice composto em `medias`: `index(['playlist_id', 'order', 'is_active'])` para ordenação de mídia\n\n**Cache de Queries Frequentes:**\n- Implementar cache de 5 minutos para `getActivePlaylists($playerId)` usando Redis\n- Cachear configurações do player por 1 hora: `getPlayerSettings($playerId)`\n- Invalidar cache automaticamente ao atualizar playlists ou configurações\n\n**Monitoramento de Performance:**\n- Adicionar log de tempo de execução em queries de sincronização\n- Implementar métricas de performance no dashboard admin\n- Criar comando `php artisan players:analyze-performance` para relatórios",
        "testStrategy": "1. Criar teste de performance `php artisan make:test PlayerSyncPerformanceTest` para medir tempo de resposta antes e depois das otimizações\n2. Testar eager loading: verificar se número de queries diminui ao sincronizar 100 players (usar `DB::enableQueryLog()`)\n3. Testar índices: executar `EXPLAIN` em queries de sincronização e verificar uso correto dos índices criados\n4. Benchmark de sincronização: criar 1000 players com playlists, medir tempo de resposta do endpoint `/api/player/sync` antes e depois\n5. Testar cache: verificar se segunda chamada de `getActivePlaylists()` retorna dados do cache Redis\n6. Testar invalidação: modificar playlist ativa, verificar se cache é limpo automaticamente\n7. Verificar memory usage: monitorar uso de memória durante sincronização massiva de players\n8. Testar queries N+1: confirmar eliminação usando Laravel Debugbar ou Telescope em ambiente de desenvolvimento",
        "status": "done",
        "dependencies": [
          9,
          33,
          59
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-20T02:30:52.097Z",
      "description": "Default tasks context",
      "updated": "2025-09-21T13:29:00.878Z"
    }
  }
}